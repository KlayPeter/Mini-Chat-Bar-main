# Mini Chat Bar èŠå¤©ç³»ç»Ÿæ–‡ä»¶å›¾ç‰‡å‘é€åŠŸèƒ½å®ç°æ–¹æ¡ˆ

## ç°çŠ¶åˆ†æ

### å½“å‰å·²æœ‰åŠŸèƒ½
1. **æ–‡ä»¶ä¸Šä¼ åŸºç¡€è®¾æ–½**ï¼šå·²æœ‰ `routes/upload.js` æä¾›æ–‡ä»¶ä¸Šä¼ API
2. **Socketæ–‡ä»¶æ¶ˆæ¯äº‹ä»¶**ï¼šå·²æœ‰ `private-file-message` Socketäº‹ä»¶å¤„ç†
3. **åŸºç¡€æ¶ˆæ¯æ¨¡å‹**ï¼š`Messages.js` æ¨¡å‹æ”¯æŒæ–‡æœ¬æ¶ˆæ¯å­˜å‚¨

### å­˜åœ¨çš„é—®é¢˜
1. **æ¶ˆæ¯æ¨¡å‹é™åˆ¶**ï¼šå½“å‰ `Messages` æ¨¡å‹åªæ”¯æŒ `content` å­—æ®µå­˜å‚¨æ–‡æœ¬
2. **ç¼ºå°‘æ–‡ä»¶æ¶ˆæ¯æŒä¹…åŒ–**ï¼šæ–‡ä»¶æ¶ˆæ¯åªé€šè¿‡Socketå®æ—¶ä¼ è¾“ï¼Œä¸å­˜å‚¨åˆ°æ•°æ®åº“
3. **æ¶ˆæ¯ç±»å‹åŒºåˆ†**ï¼šæ— æ³•åŒºåˆ†æ–‡æœ¬æ¶ˆæ¯ã€å›¾ç‰‡æ¶ˆæ¯ã€æ–‡ä»¶æ¶ˆæ¯
4. **æ–‡ä»¶è®¿é—®è·¯å¾„**ï¼šä¸Šä¼ çš„æ–‡ä»¶æ— æ³•é€šè¿‡HTTPç›´æ¥è®¿é—®

## å®ç°æ–¹æ¡ˆ

### 1. æ•°æ®åº“æ¨¡å‹å‡çº§

#### 1.1 æ‰©å±•æ¶ˆæ¯æ¨¡å‹ (models/Messages.js)
```javascript
const mongoose = require("mongoose")

const msgSchema = new mongoose.Schema({
    from: String,
    to: String,
    time: Date,
    messageType: {
        type: String,
        enum: ['text', 'image', 'file'],
        default: 'text'
    },
    content: String,  // æ–‡æœ¬æ¶ˆæ¯å†…å®¹
    fileInfo: {
        fileName: String,     // åŸå§‹æ–‡ä»¶å
        fileUrl: String,      // æ–‡ä»¶è®¿é—®URL
        fileSize: Number,     // æ–‡ä»¶å¤§å°(å­—èŠ‚)
        fileType: String,     // æ–‡ä»¶MIMEç±»å‹
        thumbnailUrl: String  // å›¾ç‰‡ç¼©ç•¥å›¾URL(å¯é€‰)
    }
})

module.exports = mongoose.model('Msg', msgSchema)
```

#### 1.2 æ•°æ®åº“è¿ç§»è„šæœ¬
```javascript
// migration/addFileSupport.js
const mongoose = require('mongoose');
const Msg = require('../models/Messages');

async function migrateMessages() {
    try {
        // ä¸ºç°æœ‰æ¶ˆæ¯æ·»åŠ é»˜è®¤messageType
        await Msg.updateMany(
            { messageType: { $exists: false } },
            { $set: { messageType: 'text' } }
        );
        console.log('æ¶ˆæ¯æ¨¡å‹è¿ç§»å®Œæˆ');
    } catch (error) {
        console.error('è¿ç§»å¤±è´¥:', error);
    }
}
```

### 2. æ–‡ä»¶ä¸Šä¼ åŠŸèƒ½å¢å¼º

#### 2.1 æ‰©å±•ä¸Šä¼ è·¯ç”± (routes/upload.js)
```javascript
const express = require('express');
const multer = require('multer');
const path = require('path');
const fs = require('fs');
const sharp = require('sharp'); // å›¾ç‰‡å¤„ç†åº“
const auth = require('../middlewares/auth');

const router = express.Router();
const UPLOADS_DIR = path.join(__dirname, 'uploads');
const THUMBNAILS_DIR = path.join(__dirname, 'uploads', 'thumbnails');

// ç¡®ä¿ç›®å½•å­˜åœ¨
[UPLOADS_DIR, THUMBNAILS_DIR].forEach(dir => {
    if (!fs.existsSync(dir)) {
        fs.mkdirSync(dir, { recursive: true });
    }
});

// æ–‡ä»¶ç±»å‹éªŒè¯
const fileFilter = (req, file, cb) => {
    const allowedTypes = {
        image: ['image/jpeg', 'image/png', 'image/gif', 'image/webp'],
        document: ['application/pdf', 'application/msword', 'application/vnd.openxmlformats-officedocument.wordprocessingml.document'],
        archive: ['application/zip', 'application/x-rar-compressed']
    };
    
    const allAllowedTypes = [...allowedTypes.image, ...allowedTypes.document, ...allowedTypes.archive];
    
    if (allAllowedTypes.includes(file.mimetype)) {
        cb(null, true);
    } else {
        cb(new Error('ä¸æ”¯æŒçš„æ–‡ä»¶ç±»å‹'), false);
    }
};

// é…ç½® Multer
const storage = multer.diskStorage({
    destination: function (req, file, cb) {
        cb(null, UPLOADS_DIR);
    },
    filename: function (req, file, cb) {
        const uniqueSuffix = Date.now() + '-' + Math.round(Math.random() * 1E9);
        cb(null, file.fieldname + '-' + uniqueSuffix + path.extname(file.originalname));
    }
});

const upload = multer({ 
    storage: storage,
    fileFilter: fileFilter,
    limits: {
        fileSize: 10 * 1024 * 1024 // 10MBé™åˆ¶
    }
});

// ç”Ÿæˆå›¾ç‰‡ç¼©ç•¥å›¾
async function generateThumbnail(filePath, filename) {
    try {
        const thumbnailPath = path.join(THUMBNAILS_DIR, 'thumb_' + filename);
        await sharp(filePath)
            .resize(200, 200, { fit: 'inside', withoutEnlargement: true })
            .jpeg({ quality: 80 })
            .toFile(thumbnailPath);
        return `/uploads/thumbnails/thumb_${filename}`;
    } catch (error) {
        console.error('ç¼©ç•¥å›¾ç”Ÿæˆå¤±è´¥:', error);
        return null;
    }
}

// èŠå¤©æ–‡ä»¶ä¸Šä¼ æ¥å£
router.post('/chat-file', auth, upload.single('file'), async (req, res) => {
    try {
        if (!req.file) {
            return res.status(400).json({ message: 'æœªä¸Šä¼ æ–‡ä»¶' });
        }

        const fileUrl = `/uploads/${req.file.filename}`;
        let thumbnailUrl = null;
        let messageType = 'file';

        // åˆ¤æ–­æ–‡ä»¶ç±»å‹
        if (req.file.mimetype.startsWith('image/')) {
            messageType = 'image';
            thumbnailUrl = await generateThumbnail(req.file.path, req.file.filename);
        }

        const fileInfo = {
            fileName: req.file.originalname,
            fileUrl: fileUrl,
            fileSize: req.file.size,
            fileType: req.file.mimetype,
            thumbnailUrl: thumbnailUrl,
            messageType: messageType
        };

        res.status(200).json({
            message: 'æ–‡ä»¶ä¸Šä¼ æˆåŠŸ',
            fileInfo: fileInfo
        });
    } catch (error) {
        console.error('æ–‡ä»¶ä¸Šä¼ å¤±è´¥:', error);
        res.status(500).json({ message: 'æ–‡ä»¶ä¸Šä¼ å¤±è´¥' });
    }
});

module.exports = router;
```

#### 2.2 é™æ€æ–‡ä»¶æœåŠ¡é…ç½® (server.js)
```javascript
// åœ¨ server.js ä¸­æ·»åŠ é™æ€æ–‡ä»¶æœåŠ¡
const express = require('express');
const path = require('path');

// æä¾›ä¸Šä¼ æ–‡ä»¶çš„é™æ€è®¿é—®
app.use('/uploads', express.static(path.join(__dirname, 'routes/uploads')));
```

### 3. èŠå¤©APIæ‰©å±•

#### 3.1 å‘é€æ–‡ä»¶æ¶ˆæ¯API (routes/chat.js)
```javascript
// æ·»åŠ åˆ° routes/chat.js
const Msg = require("../models/Messages");

// å‘é€æ–‡ä»¶æ¶ˆæ¯
router.post("/file-message/:id", auth, async (req, res) => {
    const myId = req.user.uid;
    const targetId = req.params.id;
    const { fileInfo } = req.body;
    
    try {
        const newMessage = new Msg({
            from: myId,
            to: targetId,
            time: new Date(),
            messageType: fileInfo.messageType,
            content: fileInfo.fileName, // å­˜å‚¨æ–‡ä»¶åä½œä¸ºå†…å®¹
            fileInfo: {
                fileName: fileInfo.fileName,
                fileUrl: fileInfo.fileUrl,
                fileSize: fileInfo.fileSize,
                fileType: fileInfo.fileType,
                thumbnailUrl: fileInfo.thumbnailUrl
            }
        });
        
        await newMessage.save();
        
        res.status(200).json({
            message: 'æ–‡ä»¶æ¶ˆæ¯å‘é€æˆåŠŸ',
            messageId: newMessage._id
        });
    } catch (error) {
        console.error('æ–‡ä»¶æ¶ˆæ¯å‘é€å¤±è´¥:', error);
        res.status(500).json({ message: 'æ–‡ä»¶æ¶ˆæ¯å‘é€å¤±è´¥' });
    }
});

// ä¿®æ”¹è·å–æ¶ˆæ¯çš„APIï¼Œæ”¯æŒæ–‡ä»¶æ¶ˆæ¯
router.get("/messages/:id", auth, async (req, res) => {
    const myId = req.user.uid;
    const targetId = req.params.id;
    try {
        const messages = await Msg.find({
            $or: [
                { from: myId, to: targetId },
                { from: targetId, to: myId }
            ]
        }).sort({ time: 1 });
        
        // æ ¼å¼åŒ–æ¶ˆæ¯ï¼ŒåŒºåˆ†ä¸åŒç±»å‹
        const formattedMessages = messages.map(msg => ({
            _id: msg._id,
            from: msg.from,
            to: msg.to,
            time: msg.time,
            messageType: msg.messageType || 'text',
            content: msg.content,
            fileInfo: msg.fileInfo || null
        }));
        
        res.json(formattedMessages);
    } catch (err) {
        res.status(401).json({ message: "æ¶ˆæ¯è·å–å¤±è´¥" });
    }
});
```

### 4. Socket.IO å®æ—¶é€šä¿¡å¢å¼º

#### 4.1 æ‰©å±•Socketäº‹ä»¶å¤„ç† (sockets/chat.js)
```javascript
const users = new Map();
const Msg = require('../models/Messages');

module.exports = function(socket, io) {
    // ç”¨æˆ·ç™»å½•
    socket.on("login", (userId) => {
        socket.userId = userId;
        users.set(userId, socket.id);
        console.log(`ç”¨æˆ· ${userId} å·²è¿æ¥`);
    });

    // æ–‡æœ¬æ¶ˆæ¯
    socket.on("private-message", ({ to, content }) => {
        const targetSocketId = users.get(to);
        if (targetSocketId) {
            io.to(targetSocketId).emit('private-message', {
                from: socket.userId,
                content: content,
                messageType: 'text',
                time: new Date()
            });
        }
    });

    // æ–‡ä»¶æ¶ˆæ¯ï¼ˆå¢å¼ºç‰ˆï¼‰
    socket.on("private-file-message", async ({ to, fileInfo, messageId }) => {
        const targetSocketId = users.get(to);
        if (targetSocketId) {
            console.log(`ç”¨æˆ· ${socket.userId} å‘é€æ–‡ä»¶: ${fileInfo.fileName} ç»™ç”¨æˆ· ${to}`);
            
            io.to(targetSocketId).emit("private-file-message", {
                from: socket.userId,
                messageType: fileInfo.messageType,
                fileInfo: fileInfo,
                messageId: messageId,
                time: new Date()
            });
        } else {
            console.log(`ç”¨æˆ· ${to} ä¸åœ¨çº¿ï¼Œæ–‡ä»¶æ¶ˆæ¯å·²å­˜å‚¨åˆ°æ•°æ®åº“`);
        }
    });

    // å›¾ç‰‡æ¶ˆæ¯
    socket.on("private-image-message", async ({ to, fileInfo, messageId }) => {
        const targetSocketId = users.get(to);
        if (targetSocketId) {
            io.to(targetSocketId).emit("private-image-message", {
                from: socket.userId,
                messageType: 'image',
                fileInfo: fileInfo,
                messageId: messageId,
                time: new Date()
            });
        }
    });

    // ç”¨æˆ·æ–­å¼€è¿æ¥
    socket.on("disconnect", () => {
        console.log("ç”¨æˆ·æ–­å¼€è¿æ¥:", socket.id);
        for (const [userId, socketId] of users) {
            if (socketId === socket.id) {
                users.delete(userId);
                break;
            }
        }
    });
};
```

### 5. å‰ç«¯é›†æˆæŒ‡å—

#### 5.1 æ–‡ä»¶ä¸Šä¼ ç»„ä»¶ç¤ºä¾‹
```javascript
// å‰ç«¯æ–‡ä»¶ä¸Šä¼ å‡½æ•°
async function uploadChatFile(file, targetUserId) {
    const formData = new FormData();
    formData.append('file', file);
    
    try {
        // 1. ä¸Šä¼ æ–‡ä»¶
        const uploadResponse = await fetch('/upload/chat-file', {
            method: 'POST',
            headers: {
                'Authorization': `Bearer ${token}`
            },
            body: formData
        });
        
        const uploadResult = await uploadResponse.json();
        
        if (uploadResponse.ok) {
            // 2. å‘é€æ–‡ä»¶æ¶ˆæ¯åˆ°æ•°æ®åº“
            const messageResponse = await fetch(`/chat/file-message/${targetUserId}`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${token}`
                },
                body: JSON.stringify({
                    fileInfo: uploadResult.fileInfo
                })
            });
            
            const messageResult = await messageResponse.json();
            
            // 3. é€šè¿‡Socketå‘é€å®æ—¶é€šçŸ¥
            if (messageResponse.ok) {
                socket.emit('private-file-message', {
                    to: targetUserId,
                    fileInfo: uploadResult.fileInfo,
                    messageId: messageResult.messageId
                });
            }
        }
    } catch (error) {
        console.error('æ–‡ä»¶å‘é€å¤±è´¥:', error);
    }
}
```

#### 5.2 æ¶ˆæ¯æ¸²æŸ“ç»„ä»¶
```javascript
// å‰ç«¯æ¶ˆæ¯æ¸²æŸ“å‡½æ•°
function renderMessage(message) {
    switch (message.messageType) {
        case 'text':
            return `<div class="text-message">${message.content}</div>`;
            
        case 'image':
            return `
                <div class="image-message">
                    <img src="${message.fileInfo.thumbnailUrl || message.fileInfo.fileUrl}" 
                         alt="${message.fileInfo.fileName}"
                         onclick="showFullImage('${message.fileInfo.fileUrl}')" />
                    <span class="file-name">${message.fileInfo.fileName}</span>
                </div>
            `;
            
        case 'file':
            return `
                <div class="file-message">
                    <div class="file-icon">ğŸ“„</div>
                    <div class="file-info">
                        <span class="file-name">${message.fileInfo.fileName}</span>
                        <span class="file-size">${formatFileSize(message.fileInfo.fileSize)}</span>
                    </div>
                    <a href="${message.fileInfo.fileUrl}" download="${message.fileInfo.fileName}" 
                       class="download-btn">ä¸‹è½½</a>
                </div>
            `;
            
        default:
            return `<div class="unknown-message">æœªçŸ¥æ¶ˆæ¯ç±»å‹</div>`;
    }
}
```

### 6. å®‰å…¨æ€§è€ƒè™‘

#### 6.1 æ–‡ä»¶å®‰å…¨
```javascript
// æ–‡ä»¶ç±»å‹ç™½åå•
const ALLOWED_FILE_TYPES = {
    images: ['image/jpeg', 'image/png', 'image/gif', 'image/webp'],
    documents: ['application/pdf', 'text/plain'],
    archives: ['application/zip']
};

// æ–‡ä»¶å¤§å°é™åˆ¶
const MAX_FILE_SIZE = 10 * 1024 * 1024; // 10MB

// æ–‡ä»¶åå®‰å…¨å¤„ç†
function sanitizeFileName(filename) {
    return filename.replace(/[^a-zA-Z0-9.-]/g, '_');
}

// ç—…æ¯’æ‰«æï¼ˆå¯é€‰ï¼‰
const ClamScan = require('clamscan');
const clamscan = await new ClamScan().init();

async function scanFile(filePath) {
    try {
        const scanResult = await clamscan.scanFile(filePath);
        return scanResult.isInfected === false;
    } catch (error) {
        console.error('æ–‡ä»¶æ‰«æå¤±è´¥:', error);
        return false;
    }
}
```

#### 6.2 è®¿é—®æ§åˆ¶
```javascript
// æ–‡ä»¶è®¿é—®æƒé™éªŒè¯ä¸­é—´ä»¶
function fileAccessControl(req, res, next) {
    const filePath = req.path;
    const userId = req.user?.uid;
    
    // éªŒè¯ç”¨æˆ·æ˜¯å¦æœ‰æƒé™è®¿é—®è¯¥æ–‡ä»¶
    // å¯ä»¥é€šè¿‡æ•°æ®åº“æŸ¥è¯¢æ¶ˆæ¯è®°å½•æ¥éªŒè¯
    
    next();
}

app.use('/uploads', fileAccessControl, express.static(uploadsPath));
```

### 7. æ€§èƒ½ä¼˜åŒ–

#### 7.1 å›¾ç‰‡å‹ç¼©å’Œç¼©ç•¥å›¾
```javascript
const sharp = require('sharp');

// å›¾ç‰‡è‡ªåŠ¨å‹ç¼©
async function compressImage(inputPath, outputPath) {
    await sharp(inputPath)
        .resize(1920, 1080, { fit: 'inside', withoutEnlargement: true })
        .jpeg({ quality: 85 })
        .toFile(outputPath);
}

// ç”Ÿæˆå¤šç§å°ºå¯¸ç¼©ç•¥å›¾
async function generateThumbnails(inputPath, filename) {
    const sizes = [150, 300, 600];
    const thumbnails = {};
    
    for (const size of sizes) {
        const thumbPath = `thumbnails/${size}_${filename}`;
        await sharp(inputPath)
            .resize(size, size, { fit: 'inside' })
            .jpeg({ quality: 80 })
            .toFile(path.join(UPLOADS_DIR, thumbPath));
        thumbnails[`thumb_${size}`] = `/uploads/${thumbPath}`;
    }
    
    return thumbnails;
}
```

#### 7.2 æ–‡ä»¶æ¸…ç†ä»»åŠ¡
```javascript
// å®šæœŸæ¸…ç†æœªä½¿ç”¨çš„æ–‡ä»¶
const cron = require('node-cron');

// æ¯å¤©å‡Œæ™¨2ç‚¹æ‰§è¡Œæ¸…ç†
cron.schedule('0 2 * * *', async () => {
    console.log('å¼€å§‹æ¸…ç†æœªä½¿ç”¨çš„æ–‡ä»¶...');
    
    try {
        // æŸ¥æ‰¾æ•°æ®åº“ä¸­å¼•ç”¨çš„æ‰€æœ‰æ–‡ä»¶
        const usedFiles = await Msg.distinct('fileInfo.fileUrl', {
            messageType: { $in: ['image', 'file'] }
        });
        
        // æ‰«æä¸Šä¼ ç›®å½•
        const uploadedFiles = fs.readdirSync(UPLOADS_DIR);
        
        // åˆ é™¤æœªè¢«å¼•ç”¨çš„æ–‡ä»¶
        for (const file of uploadedFiles) {
            const fileUrl = `/uploads/${file}`;
            if (!usedFiles.includes(fileUrl)) {
                fs.unlinkSync(path.join(UPLOADS_DIR, file));
                console.log(`å·²åˆ é™¤æœªä½¿ç”¨æ–‡ä»¶: ${file}`);
            }
        }
    } catch (error) {
        console.error('æ–‡ä»¶æ¸…ç†å¤±è´¥:', error);
    }
});
```

### 8. å®æ–½æ­¥éª¤

#### é˜¶æ®µä¸€ï¼šåŸºç¡€åŠŸèƒ½å®ç°
1. å‡çº§æ¶ˆæ¯æ•°æ®æ¨¡å‹
2. æ‰©å±•æ–‡ä»¶ä¸Šä¼ API
3. ä¿®æ”¹èŠå¤©APIæ”¯æŒæ–‡ä»¶æ¶ˆæ¯
4. é…ç½®é™æ€æ–‡ä»¶æœåŠ¡

#### é˜¶æ®µäºŒï¼šå®æ—¶é€šä¿¡å¢å¼º
1. æ‰©å±•Socket.IOäº‹ä»¶å¤„ç†
2. å®ç°æ–‡ä»¶æ¶ˆæ¯å®æ—¶æ¨é€
3. æ·»åŠ æ¶ˆæ¯çŠ¶æ€ç®¡ç†

#### é˜¶æ®µä¸‰ï¼šç”¨æˆ·ä½“éªŒä¼˜åŒ–
1. å®ç°å›¾ç‰‡ç¼©ç•¥å›¾ç”Ÿæˆ
2. æ·»åŠ æ–‡ä»¶é¢„è§ˆåŠŸèƒ½
3. ä¼˜åŒ–ä¸Šä¼ è¿›åº¦æ˜¾ç¤º
4. å®ç°æ‹–æ‹½ä¸Šä¼ 

#### é˜¶æ®µå››ï¼šå®‰å…¨æ€§å’Œæ€§èƒ½
1. æ·»åŠ æ–‡ä»¶ç±»å‹å’Œå¤§å°éªŒè¯
2. å®ç°è®¿é—®æƒé™æ§åˆ¶
3. æ·»åŠ æ–‡ä»¶æ¸…ç†æœºåˆ¶
4. æ€§èƒ½ç›‘æ§å’Œä¼˜åŒ–

### 9. æµ‹è¯•æ–¹æ¡ˆ

#### 9.1 å•å…ƒæµ‹è¯•
```javascript
// æµ‹è¯•æ–‡ä»¶ä¸Šä¼ API
describe('File Upload API', () => {
    test('should upload image file successfully', async () => {
        const response = await request(app)
            .post('/upload/chat-file')
            .attach('file', 'test-image.jpg')
            .set('Authorization', `Bearer ${token}`);
            
        expect(response.status).toBe(200);
        expect(response.body.fileInfo.messageType).toBe('image');
    });
});
```

#### 9.2 é›†æˆæµ‹è¯•
```javascript
// æµ‹è¯•å®Œæ•´çš„æ–‡ä»¶æ¶ˆæ¯å‘é€æµç¨‹
describe('File Message Flow', () => {
    test('should send file message end-to-end', async () => {
        // 1. ä¸Šä¼ æ–‡ä»¶
        const uploadResponse = await uploadFile();
        
        // 2. å‘é€æ¶ˆæ¯
        const messageResponse = await sendFileMessage(uploadResponse.fileInfo);
        
        // 3. éªŒè¯æ•°æ®åº“å­˜å‚¨
        const savedMessage = await Msg.findById(messageResponse.messageId);
        expect(savedMessage.messageType).toBe('file');
        
        // 4. éªŒè¯Socketäº‹ä»¶
        expect(socketMock.emit).toHaveBeenCalledWith('private-file-message');
    });
});
```

## æ€»ç»“

è¿™ä¸ªå®ç°æ–¹æ¡ˆæä¾›äº†å®Œæ•´çš„æ–‡ä»¶å’Œå›¾ç‰‡å‘é€åŠŸèƒ½ï¼ŒåŒ…æ‹¬ï¼š

1. **æ•°æ®æŒä¹…åŒ–**ï¼šæ‰©å±•æ¶ˆæ¯æ¨¡å‹æ”¯æŒå¤šç§æ¶ˆæ¯ç±»å‹
2. **æ–‡ä»¶ç®¡ç†**ï¼šå®Œæ•´çš„æ–‡ä»¶ä¸Šä¼ ã€å­˜å‚¨ã€è®¿é—®æœºåˆ¶
3. **å®æ—¶é€šä¿¡**ï¼šåŸºäºSocket.IOçš„å®æ—¶æ–‡ä»¶æ¶ˆæ¯æ¨é€
4. **ç”¨æˆ·ä½“éªŒ**ï¼šå›¾ç‰‡ç¼©ç•¥å›¾ã€æ–‡ä»¶é¢„è§ˆã€è¿›åº¦æ˜¾ç¤º
5. **å®‰å…¨æ€§**ï¼šæ–‡ä»¶ç±»å‹éªŒè¯ã€è®¿é—®æ§åˆ¶ã€å®‰å…¨æ‰«æ
6. **æ€§èƒ½ä¼˜åŒ–**ï¼šå›¾ç‰‡å‹ç¼©ã€æ–‡ä»¶æ¸…ç†ã€ç¼“å­˜æœºåˆ¶

é€šè¿‡åˆ†é˜¶æ®µå®æ–½ï¼Œå¯ä»¥é€æ­¥å®Œå–„èŠå¤©ç³»ç»Ÿçš„æ–‡ä»¶å‘é€åŠŸèƒ½ï¼Œä¸ºç”¨æˆ·æä¾›æ›´ä¸°å¯Œçš„æ²Ÿé€šä½“éªŒã€‚