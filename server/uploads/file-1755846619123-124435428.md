# git 远程协作

origin？？

在 Git 中，其实无论是 `origin`，还是 `upstream` 并没有特殊的含义，但由于被广泛使用，因此它们有了约定俗成、众所周知的含义。



## 拉取远程分支

### git push失败？

```bash
$ git push origin main
# 你在本地的git代码推送推到远程，额，远程在哪里？？
```

所以肯定拉取远程分支然后再推的呀

我们需要做的就是把本地的 `git-test` 仓库与远程仓库关联一下

```bash
$ git remote add origin <repo_address>
```

关联之后，再进行 Push 就能成功了。



那么 `git remote add` 内部做了什么默默无闻的工作呢，它其实是往 `.git/config` 中写入了一个叫 `[remote "origin"]` 配置：

```cobol
[core]
	repositoryformatversion = 0
	filemode = false
	bare = false
	logallrefupdates = true
	symlinks = false
	ignorecase = true
[remote "origin"]
	url = https://gitee.com/jsxztshaohaibo/git-usage-test.git
	fetch = +refs/heads/*:refs/remotes/origin/*
```

>  如果你本地的仓库是通过 `git clone` 下来的，Git 会默认将远程仓库命名为 `origin`，自动帮你关联上远端仓库（可在 `.git/config` 文件中看到已有 `[remote "origin"]` 配置项了），因此 Commit 之后就能直接 Push 了。

### 分析配置

我们来分析一下，这配置表示什么意思。

```cobol
[remote "origin"]
	url = https://gitee.com/jsxztshaohaibo/git-usage-test.git
	fetch = +refs/heads/*:refs/remotes/origin/*
```

通过` git remote add` 命令，添加了一个叫做 origin 的远程名称（Remote Name），

- 其中 url 参数，表示该远程名称对应的远程仓库地址。
- 其中 fetch 参数分为两部分，以冒号 : 进行分割，冒号左边表示本地仓库文件夹，冒号右边表示远程仓库在本地的副本文件夹。里面的加号 + 表示往里面添加数据的意思。

> **请注意，`origin` 只是一个名称（别名），用于指向远程仓库。这个别名是可以自行修改的，比如命名为 `foo`、`bar` 等。使用别名好处是「简单、方便、好记(就像网址和IP的关系)」。**

以下两条命令是完全等效的

```bash
$ git push origin master
$ git push https://gitee.com/jsxztshaohaibo/git-usage-test.git master
```

也就是说origin其实就是一个**别名**

### 换名

那么当然是可以更换这个名称的：

```bash
# 新增远程名称（一个本地仓库，可以关联多个远程仓库）
$ git remote add <remote-name> <repo-address>
 
# 删除已存在远程名称（只会移除本地仓库与远程仓库的管理，不会删除远程仓库的代码哈）
$ git remote rm <remote-name>
 
# 更新远程名称关联的远程仓库
$ git remote set-url <remote-name> <repo-address>
 
# 修改远程名称（也可以先删除再添加）
$ git remote rename <old-remote-name> <new-remote-name>
```

比如使用 `git remote set-url` 修改关联的远程仓库地址：

![img](https://i-blog.csdnimg.cn/blog_migrate/d370f9e1160cf8df456ce153f4f642b6.png)

然后，我们修改下远程名称为 `main`，也是可以的：

![img](https://i-blog.csdnimg.cn/blog_migrate/f3b36e7ebd61a40ae417d18a938276b1.png)

接着，我们随意修改个文件 Push 一下，是这样的 `git push main master `：

![img](https://i-blog.csdnimg.cn/blog_migrate/fa1f704287f69674d5b54ea144606349.png)

### 关联多个远程仓库

一个本地仓库是可以关联多个远程仓库的

举个例子：

我们新建一个远程仓库的地址，给新的仓库地址 起一个别名 origin

```bash
$ git remote add origin https://gitee.com/jsxztshaohaibo/git-usage-test.git
```

![img](https://i-blog.csdnimg.cn/blog_migrate/686e7db9836052f8a842254b767ee193.png)

可以看到main和origin分别指向了两个不同的远程仓库，然后使用

```bash
# 将本地的 master 分支推送至 main 对应的远程仓库（git-usage-test-02.gt）
$ git push main master 
 
# 将本地的 master分支推送至 origin 对应的远程仓库（git-usage-test.git）
$ git push origin master
```



## 远程分支（Remote Branch）

常说的「远程分支」是远程仓库对应分支在本地的一个副本

比如常见的 `origin/master`、`origin/main`、`origin/develop` 等都是远程分支，**可以在 `.git/refs/remotes/` 目录下看到。**

```bash
# 查看所有本地分支
$ git branch
 
# 查看所有远程分支（-r 是 --remotes 的简写）
$ git branch -r
 
# 查看所有本地分支和远程分支（-a 是 --all 的简写）
$ git branch -a
```

 将远程名称修改之后，远程分支名称也会跟着改变的。

比如：将 Remote Name 由 `origin` 修改为 `foo`，那么远程分支，会由 `origin/main` 变为 `foo/main` 





## 拉取最新代码

通常，拉取最新代码的过程是这样的： 

- 通过 `git fetch` 
-  拉取代码的过程：先读取 .git/config 文件里面的配置 [remote <remote-name>]，将里面的所有（因为 fetch 并没有指定其中一个或多个远程仓库）远程名称对应仓库的分支下载到本地，并放在 `.git/refs/remotes/<remote-name>/ `目录下。

- 有时候，我们可能会通过 `git diff` 命令来对比本地分支与远程分支的一些信息，才决定要不要合并。比如，`git diff main origin/main`。
- 通过 `git merge` 或 `git rebase` 来进行分支合并。**比如 `git merge origin/main`，表示将远程分支 `origin/main` 合并至本地分支 `main` 中。**

也可以直接使用 **`git pull` **命令，其实包括了 `git fetch` 和 `git merge` 两个过程



# 推送代码基本流程

然后我们推送代码的时候一般使用

```bash
$ git add .
$ git commit -m "commit message"
$ git push origin
```

`git push origin`命令用于将当前分支的所有提交推送到远程仓库

那如果我使用

```bash
$ git push origin HEAD
```

作用应该说是一样的

HEAD表示当前分支，origin表示远程仓库的名称。



**区别**

那他们有什么区别呢？git push origin HEAD和git push origin之间的区别在于指定提交的方式。

当使用`git push origin HEAD`命令时，我们明确指定了要推送的提交是当前分支的所有提交。

而当使用`git push origin`命令时，git会自动推送当前分支的所有提交。



如果推送到远程特定的分支

```bash
$ git push origin main

$ git push origin HEAD:main
```







git合并分支

整合分支最容易的方法是 merge 命令

 它会把两个分支的最新快照（C3 和 C4）以及二者最近的共同祖先（C2）进行三方合并，合并的结果是生成一个新的快照（并提交）

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/b0b7db1f49b47676334c55539c322bfa.png)

```bash
# 合并指定分支到当前分支
$ git merge <branch>
```



```bash
$ git switch master
$ git merge experiment

# 没有冲突时不需要下方的命令。有冲突时，就修改冲突文件，再add然后commit该文件，如下：
$ git add readme.txt 
$ git commit -m "conflict fixed"

```

删除dev分支：

```bash
$ git branch -d dev
```



# 分支的新建与合并

在开发过程中，我们常常需要针对不同的需求或问题创建分支，分别进行开发、修复和合并。下面通过一个完整的工作流示例，来说明如何在 Git 中新建分支、处理紧急问题、合并分支等操作。

## 一、基本工作流程

1. 正在开发某个网站。
2. 为实现一个新的用户需求，创建一个新分支。
3. 在该分支上持续开发功能。

此时，突然接到电话，有一个严重的问题需要紧急修复。你需要：

1. 切换回线上分支（production 分支，假设为 `master`）。
2. 新建一个专门用于紧急修复的分支，并进行修复。
3. 修复完成并测试通过后，将该分支合并回 `master`，并推送到远程仓库。
4. 最后切换回原来的开发分支，继续未完成的功能开发。

---

## 二、新建分支并开始功能开发

假设当前已经在 `master` 分支上开发了一段时间

![一个简单的提交历史。](https://git-scm.com/book/zh/v2/images/basic-branching-1.png)

现在准备修复任务追踪系统中的 Issue #53，我们将新建并切换到 `iss53` 分支：

```bash
$ git checkout -b iss53
```

等价于以下两条命令：

```bash
$ git branch iss53
$ git checkout iss53
```

此时分支结构如下：

![新建分支后的指针状态](https://git-scm.com/book/zh/v2/images/basic-branching-2.png)

随后你在 `iss53` 分支上进行了若干次提交，例如：

```bash
$ vim index.html
$ git commit -a -m 'added a new footer [issue 53]'
```

分支状态更新如下：

![iss53 分支推进](https://git-scm.com/book/zh/v2/images/basic-branching-3.png)

---

## 三、处理中断：紧急修复问题

正在开发中，突然有紧急问题需要修复。为避免混淆不同任务的提交，我们通过如下步骤来单独处理该问题。

### 1. 切换回 `master` 分支

确保当前工作区无未提交更改（或使用 `git stash` 暂存），然后切换：

```bash
$ git checkout master
```

### 2. 新建 `hotfix` 分支进行修复

```bash
$ git checkout -b hotfix
$ vim index.html
$ git commit -a -m 'fixed the broken email address'
```

修复结构如下图：

![hotfix 分支创建并提交](https://git-scm.com/book/zh/v2/images/basic-branching-4.png)

### 3. 合并回 `master` 并推送

```bash
$ git checkout master
$ git merge hotfix
```

合并为 Fast-forward 模式（无冲突）：

![master 快进合并 hotfix](https://git-scm.com/book/zh/v2/images/basic-branching-5.png)

修复完成后，可以删除 `hotfix` 分支：

```bash
$ git branch -d hotfix
```

---

## 四、继续原有开发任务

回到原本的 `iss53` 分支继续开发：

```bash
$ git checkout iss53
$ vim index.html
$ git commit -a -m 'finished the new footer [issue 53]'
```

此时，`iss53` 分支仍未包含 `hotfix` 的更改。如果需要，也可以合并 `master` 到 `iss53` 来同步紧急修复内容：

```bash
$ git merge master
```

---

## 五、功能完成后合并到主分支

当 #53 问题修复完成，可以将 `iss53` 分支合并回 `master`：

```bash
$ git checkout master
$ git merge iss53
```

如果两个分支存在分叉（即非 Fast-forward），将会触发三方合并：

![三方合并原理](https://git-scm.com/book/zh/v2/images/basic-merging-1.png)

Git 会创建一个新的合并提交（merge commit）：

![合并提交的结构图](https://git-scm.com/book/zh/v2/images/basic-merging-2.png)

合并完成后，可删除该分支：

```bash
$ git branch -d iss53
```

---

## 六、合并冲突的处理

当两个分支修改了同一文件的同一部分内容，Git 无法自动合并，将提示冲突信息：

```bash
$ git merge iss53
Auto-merging index.html
CONFLICT (content): Merge conflict in index.html
Automatic merge failed; fix conflicts and then commit the result.
```

此时可使用：

```bash
$ git status
```

查看所有未解决的冲突文件。解决完冲突后，通过以下命令完成合并：

```bash
$ git add index.html
$ git commit
```

---







## git cherry-pick

对于多分支的代码库，将代码从一个分支转移到另一个分支是常见需求

这时分两种情况：

- 一种情况是，你需要另一个分支的所有代码变动，那么就采用合并（`git merge`）；
- 另一种情况是，你只需要部分代码变动（某几个提交），这时可以采用 Cherry pick。

`git cherry-pick`可以理解为"挑拣"提交，它会获取某一个分支的单笔/多笔提交，并作为一个新的提交引入到你当前分支上

当我们需要在本地合入其他分支的提交时，如果我们不想对整个分支进行合并，而是只想将某一次提交合入到本地当前分支上，那么就要使用`git cherry-pick`了。

### 一、基本用法

git cherry-pick 命令的作用，就是将指定的提交commit 应用到其他分支

```bash
$ git cherry-pick <commitHash>
```

```bash

# 查看最近三次提交
$ git log --oneline -3
23d9422 [Description]:branch2 commit 3
2555c6e [Description]:branch2 commit 2
b82ba0f [Description]:branch2 commit 1

```

上面命令就会将指定的提交`commitHash`，应用于当前分支。这会在当前分支产生一个新的提交，当然它们的哈希值会不一样。

举例来说，代码仓库有`master`和`feature`两个分支。

```cobol
    a - b - c - d   Master
         \
           e - f - g Feature
```

现在将提交`f`应用到`master`分支。

```bash
# 切换到master分支
$ git checkout master

# Cherry pick操作
$ git cherry-pick f
```

上面的操作完成以后，代码库就变成了下面的样子。

```
     a - b - c - d - f   Master
         \
           e - f - g Feature
```

从上面可以看到，`master`分支的末尾增加了一个提交`f`

`git cherry-pick`命令的参数，不一定是提交的哈希值，分支名也是可以的，表示转移该分支的最新提交

```bash
$ git cherry-pick feature # 表示将feature分支的最近一次提交，转移到当前分支
```

### 二、转移多个提交

Cherry pick 支持一次转移多个提交

```bash
$ git cherry-pick <HashA> <HashB>
```

上面的命令将A和B两个提交应用到当前的分支。这会再当前分支生成两个对应的新提交

如果想要转移一系列的连续的提交，可以使用下面的简便语法

```bash
# 不包含A，包含B
$ git cherry-pick A..B
```

上面的命令可以转移A到B的所有提交

它们必须按照正确的顺序放置：提交 A 必须早于提交 B，否则命令将失败，但不会报错。

> **注意**，使用上面的命令，提交 A 将不会包含在 Cherry pick 中，即`git cherry-pick (commitidA…commitidB]`。如果要包含提交 A，可以使用下面的语法。
>
> ```bash
> // 如果想搞成[]区间，使用 git cherry-pick A^..B 相当于[A B]包含A
> $ git cherry-pick A^..B 
> ```

### 三、配置项

`git cherry-pick`命令的常用配置项如下。

1. -e，--edit

   打开外部编辑器，编辑提交信息。

2. -n，--no-commit

   只更新工作区和暂存区，不产生新的提交。

3. -x

   在提交信息的末尾追加一行(cherry picked from commit ...)，方便以后查到这个提交是如何产生的。

4. -s，--signoff

   在提交信息的末尾追加一行操作者的签名，表示是谁进行了这个操作。

5. -m parent-number，--mainline parent-number

   如果原始提交是一个合并节点，来自于两个分支的合并，那么 Cherry pick 默认将失败，因为它不知道应该采用哪个分支的代码变动。

### 四、代码冲突

如果操作过程中发生代码冲突，Cherry pick 会停下来，让用户决定如何继续操作。

- `--continue`

  用户解决代码冲突后，第一步将修改的文件重新加入暂存区（git add .），第二步使用下面的命令，让 Cherry pick 过程继续执行。

  ```bash
  $ git cherry-pick --continue
  ```

- `--abort`

  发生代码冲突后，放弃合并，回到操作前的样子。

  ```bash
  $ git cherry-pick --abort
  ```

- `--quit`

  发生代码冲突后，退出cherry pick，但是不会到操作前的样子

  ```bash
  $ git cherry-pick --quit
  ```

  

### 五、转移到另一个代码库

Cherry pick 也支持转移另一个代码库的提交，方法是先将该库加为远程仓库。

```bash
$ git remote add target git://gitUrl
```

上面命令添加了一个远程仓库target。

然后，将远程代码抓取到本地。

```bash
$ git fetch target
```

上面命令将远程代码仓库抓取到本地。

接着，检查一下要从远程仓库转移的提交，获取它的哈希值。

```bash
$ git log target/master
```

最后，使用git cherry-pick命令转移提交。

```bash
$ git cherry-pick <commitHash>
```





## 撤销操作

先来看看场景

有时候我们提交完了才发现漏掉了几个文件没有添加，或者提交信息写错了。 此时，可以运行带有 `--amend` 选项的提交命令来重新提交：

```bash
$ git commit --amend
```

这个命令会将暂存区的文件提交，修改的只是提交信息

例如，你提交后发现忘记了暂存某些需要的修改，可以像下面这样操作：

```bash
$ git commit -m 'initial commit'
$ git add forgotten_file
$ git commit --amend
```

只会有一个提交——第二次提交将代替第一次提交的结果。

### 取消暂存的文件

如何操作暂存区和工作目录中已修改的文件？

 例如，你已经修改了两个文件并且想要将它们作为两次独立的修改提交， 但是却意外地输入 `git add *` 暂存了它们两个。如何只取消暂存两个中的一个呢？

你可以用`git status`命令提示

```bash
$ git add *
$ git  status
On branch master
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

    renamed:    README.md -> README
    modified:   CONTRIBUTING.md
```

在 “Changes to be committed” 文字正下方，提示使用 `git reset HEAD <file>…` 来取消暂存

 所以，我们可以这样来取消暂存 `CONTRIBUTING.md` 文件：

```bash
$ git reset HEAD CONTRIBUTING.md
Unstaged changes after reset:
M	CONTRIBUTING.md
$ git status
On branch master
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

    renamed:    README.md -> README

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

    modified:   CONTRIBUTING.md
```

这个命令有点儿奇怪，但是起作用了。 `CONTRIBUTING.md` 文件已经是修改未暂存的状态了。

### 撤消对文件的修改

如果你并不想保留对 `CONTRIBUTING.md` 文件的修改怎么办？ 你该如何方便地撤消修改——将它还原成上次提交时的样子（

幸运的是，`git status` 也告诉了你应该如何做。 在最后一个例子中，未暂存区域是这样：

```bash
Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

    modified:   CONTRIBUTING.md
```

它非常清楚地告诉了你如何撤消之前所做的修改。 让我们来按照提示执行：

```bash
$ git checkout -- CONTRIBUTING.md
$ git status
On branch master
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

    renamed:    README.md -> README
```

## 回退分支

分支回滚

1. 使用 `git reset` 命令

   > 命令可以将当前分支的HEAD指针指向指定的提交，从而回退代码到指定版本
   >
   > 该命令有三种模式

   - --mixed （默认）：将 HEAD 指针和暂存区都回退到指定提交，但不改变工作区的内容
   - --soft 仅将HEAD指针回退到指定提交，不改变暂存区和工作区的内容
   - --hard 将 HEAD 指针、暂存区和工作区都回退到指定提交，会丢失最新的代码修改，慎用

   ```bash
   # 查看提交历史
   $ git log
   # 回退到指定提交（使用 --soft 模式）
   $ git reset --soft <commit>
   # 查看状态，确认回退操作是否正确
   $ git status
   
   # 提交回退后的代码 
   git commit -m "回退到<commit>"
   
   # 将修改的代码推送到远程仓库
   git push origin <branch>
   
   ```

2. 使用`git revert`命令

   > git revert 命令可以将指定提交的修改反向应用到当前分支上，相当于`撤销指定提交的修改`。

   ```bash
   # 查看提交历史
   $ git log
   
   # 撤销指定提交，这样会创建一个新的提交来撤销之前的修改
   $ git revert <commit>
   
   # 提交撤销操作
   $ git commit -m "回退到版本<commit>"
   
   # 推送到远程仓库
   $ git push origin <branch>
   ```

3. 使用 `git checkout` 命令

   > git checkout 命令可以将当前分支的 HEAD 指针指向指定的提交，并将工作区的内容替换成指定提交的内容

   ```bash
   # 查看提交历史
   $ git log
   
   # 切换到指定提交
   git checkout <branch>
   
   # 提交回退后的代码
   $ git commit -m "回退到版本 <commit>"
   
   # 切换到原来的分支
   $ git checkout <branch>
   
   # 推送当前的分支到远程仓库
   git push origin <branch>
   #<branch> 表示当前分支的名称，例如 master。这个命令会将本地分支的提交推送到远程仓库，并将远程分支更新为与本地分支一致
   ```

   







当我想撤回已经推送到远程分支的分支，我要怎么处理

首先

可以看一下提交的日志

git log

然后选择跳哪一个版本

或者用git reset HEAD~1返回最近上一个版本

然后你可以强制推送你的版本过去远程分支

但是不知道这个后果是什么，可以做到与本地的同步

git push --force



记住千万不要git pull 不然会有很大的冲突

遇到这种情况最好的办法是放弃合并 并拉取远程分支，

git branch backup-testing

git merge --abort

git reset --hard origin/testing

git pull origin/testing

​		



## git的小弯弯

现在所在的分支是main分支

可以用`git branch` 查看当前的分支

```bash
git branch           # 本地分支
git branch -r        # 远程分支
git branch -a        # 所有分支
```



创建 dev 分支（小弯弯起点）

```bash
git checkout main
git checkout -b dev
# 下面是新语法，作用一样
git switch main
git switch -c dev
```

在 dev 上开发并提交两次

```bash
# 模拟更改1
echo "<p>第一次更改</p>" >> pages/index/index.html
git add .
git commit -m "dev: 第一次更改"

# 模拟更改2
echo "<p>第二次更改</p>" >> pages/index/index.html
git add .
git commit -m "dev: 第二次更改"
```

切换回 main，添加一个不同的提交！

这是关键步骤！

```bash
git switch main
echo "<!-- main 的更新 -->" >> pages/about/index.html
git add .
git commit -m "main: 修改了 about 页面"

```

合并 dev 回 main

```bash
git merge dev
```

> 因为 `main` 有自己的提交，Git 不能快进合并，只能通过真正的 **三方合并**，这样就会产生一个“弯出来再合并回去”的结构！

再次查看图形结构

```bash
git log --graph --oneline --all

```

你将看到类似下面这种结构：

```markdown
*   abc1234 (HEAD -> main) Merge branch 'dev'
|\
| * def5678 (dev) dev: 第二次更改
| * 789abcd dev: 第一次更改
* | 456def0 main: 修改了 about 页面
|/
* 0123456 之前的提交...
```

想避免 **fast-forward（快进）合并**，但是又不想在 `main` 分支额外提交内容

使用 `--no-ff` 参数合并

当你执行合并时，明确告诉 Git **不要使用快进合并**，而是生成一个新的合并提交：

```bash
git checkout main
git merge --no-ff dev # --no-ff 意思是 no fast-forward，不使用快进合并。
```



# git stash

命令使用

基本的 *git stash* 命令会将你的工作目录和暂存区的更改保存起来，使得工作目录回到一个干净的状态。这样，你就可以切换分支而不会带着未提交的更改。使用方法如下：

```bash
git stash
```

这个命令会保存你的更改到一个临时的地方，称为“stash”。你可以在任何时候恢复这些更改，或者查看保存的更改列表：

```bash
git stash list
```

当你准备好恢复之前的更改时，可以使用以下命令：

```bash
git stash pop
```

这会应用最新的暂存更改并从暂存列表中移除它。如果你想要应用特定的暂存更改，可以指定一个 *stash_id*，这个 ID 可以通过 *git stash list* 命令获得：

```bash
git stash pop stash@{1}
```

如果你只想应用更改而不从暂存列表中删除它，可以使用 *apply* 命令：

```bash
git stash apply
```

此外，你还可以删除一个或所有的暂存更改：

```bash
git stash drop stash@{1} # 删除指定的暂存更改

git stash clear # 删除所有的暂存更改
```

