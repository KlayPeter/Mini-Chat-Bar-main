# Coffee Chat Bar 项目面试技术问答文档

## 目录
1. [项目概述](#项目概述)
2. [前端技术栈问答](#前端技术栈问答)
3. [后端技术栈问答](#后端技术栈问答)
4. [数据库设计问答](#数据库设计问答)
5. [实时通信问答](#实时通信问答)
6. [前后端交互问答](#前后端交互问答)
7. [安全性问答](#安全性问答)
8. [性能优化问答](#性能优化问答)
9. [项目架构问答](#项目架构问答)
10. [Electron桌面端问答](#electron桌面端问答)

---

## 项目概述

### Q1: 请介绍一下这个项目的整体架构
**A:** 这是一个基于Vue 3 + Node.js的全栈实时聊天应用，采用前后端分离架构：
- **前端**: Vue 3 + Vite + Pinia + Vue Router + Socket.IO Client
- **后端**: Node.js + Express + MongoDB + Socket.IO + JWT
- **桌面端**: Electron封装
- **数据库**: MongoDB存储用户信息、消息记录等
- **实时通信**: Socket.IO实现WebSocket双向通信

### Q2: 项目的主要功能有哪些？
**A:** 主要功能包括：
1. 用户注册登录（JWT认证）
2. 私聊功能（一对一实时消息）
3. 群聊功能（多人聊天室）
4. 文件传输（图片、文档等）
5. AI助手集成（DeepSeek API）
6. 好友管理系统
7. 跨平台桌面端支持

---

## 前端技术栈问答

### Q3: 为什么选择Vue 3而不是Vue 2？
**A:** 选择Vue 3的原因：
1. **Composition API**: 项目中使用了`<script setup>`语法，如在`ChatView.vue`中：
```javascript
<script setup>
import { onMounted, ref, watch } from "vue";
const showlastchats = ref(true);
const showcontacts = ref(false);
</script>
```
2. **更好的TypeScript支持**
3. **性能提升**: 更小的包体积，更快的渲染
4. **更好的Tree-shaking支持**

### Q4: 项目中如何实现状态管理？
**A:** 使用Pinia进行状态管理，在`useChatStore.js`中定义：
```javascript
export const useChatStore = defineStore('chat',{
    state:()=>({
        currentChatUser:null,
        messageLists:{}
    }),
    actions:{
        switchChatUser(user){
            this.currentChatUser = user
        },
        addMessage(userID,message){
            if(!this.messageLists[userID]){
                this.messageLists[userID] = []
            }
            this.messageLists[userID].push(message)
        }
    }
})
```
**优势**: 相比Vuex更简洁，支持TypeScript，更好的开发体验

### Q5: 路由是如何配置的？有哪些路由守卫？
**A:** 在`router/index.js`中配置：
```javascript
const routes = [
  { path: '/', component: ChatView, meta:{requiresAuth:true} },
  { path: '/chatbox', component: ChatBox, meta:{requiresAuth:true} },
  { path: '/login', component: Login }
]

router.beforeEach((to,from,next)=>{
  const isLoggedIn = localStorage.getItem('token')
  if(to.meta.requiresAuth && !isLoggedIn){
    next("/login")
  } else {
    next()
  }
})
```
**路由守卫作用**: 检查用户是否已登录，未登录用户访问需要认证的页面时自动跳转到登录页

### Q6: 项目中如何处理响应式设计？
**A:** 在`App.vue`中使用CSS媒体查询：
```css
/* 大屏幕设备 */
@media (min-width: 1200px) {
  html, body, #app { border-radius: 1rem; }
}

/* 移动设备 */
@media (max-width: 768px) {
  html, body, #app {
    border-radius: 0;
    height: -webkit-fill-available; /* iOS Safari 兼容 */
  }
}
```
同时在`ChatView.vue`中使用`isMobile`响应式变量控制组件显示

### Q7: 如何实现组件间通信？
**A:** 项目中使用多种通信方式：
1. **Props/Emit**: 父子组件通信
```javascript
// 子组件向父组件发送事件
<LastChats @todetail="showdetail" />
```
2. **Pinia Store**: 跨组件状态共享
3. **Event Bus**: Socket.IO事件系统

### Q8: 项目中使用了哪些第三方UI库？
**A:** 主要使用：
1. **FontAwesome**: 图标库
```javascript
import { faComment, faEye, faUsers } from '@fortawesome/free-solid-svg-icons'
library.add(faComment, faEye, faUsers)
```
2. **Vue3-Emoji-Picker**: 表情选择器
3. **自定义组件**: 大部分UI组件都是自己开发的，保证了设计的一致性

---

## 后端技术栈问答

### Q9: 后端服务器是如何搭建的？
**A:** 使用Express.js搭建，在`server.js`中：
```javascript
const express = require('express')
const http = require('http')
const { Server } = require('socket.io')

const app = express()
const server = http.createServer(app)
const io = new Server(server, { cors: { origin: '*' } })

// 中间件配置
app.use(cors({ origin: '*' }))
app.use(express.json())
app.use(express.urlencoded({ extended: true }))

// 路由配置
app.use('/user', userRouter)
app.use('/chat', chatRouter)
app.use('/api/upload', uploadRouter)
```

### Q10: 如何处理用户认证？
**A:** 采用JWT + 中间件的多层认证体系：

**1. 后端JWT生成和验证：**
```javascript
// routes/user.js - 登录接口详细实现
const jwt = require('jsonwebtoken');
const bcrypt = require('bcrypt');
const Users = require('../models/Users');

// 登录路由处理
router.post('/login', async (req, res) => {
  try {
    const { username, password } = req.body;
    
    // 1. 输入验证
    if (!username || !password) {
      return res.status(400).json({
        success: false,
        message: '用户名和密码不能为空'
      });
    }
    
    // 2. 查找用户（支持用户名或邮箱登录）
    const user = await Users.findOne({
      $or: [
        { username: username },
        { email: username }
      ]
    }).select('+password'); // 显式包含密码字段
    
    if (!user) {
      return res.status(401).json({
        success: false,
        message: '用户不存在'
      });
    }
    
    // 3. 验证密码
    const isPasswordValid = await bcrypt.compare(password, user.password);
    if (!isPasswordValid) {
      // 记录失败尝试（防暴力破解）
      await logFailedAttempt(user._id, req.ip);
      
      return res.status(401).json({
        success: false,
        message: '密码错误'
      });
    }
    
    // 4. 检查账户状态
    if (user.status === 'disabled') {
      return res.status(403).json({
        success: false,
        message: '账户已被禁用'
      });
    }
    
    // 5. 生成JWT Token
    const tokenPayload = {
      userId: user._id,
      username: user.username,
      role: user.role || 'user',
      iat: Math.floor(Date.now() / 1000), // 签发时间
      jti: generateUniqueId() // JWT ID，用于token撤销
    };
    
    const accessToken = jwt.sign(
      tokenPayload,
      process.env.JWT_SECRET,
      { 
        expiresIn: '15m', // 访问token短期有效
        issuer: 'coffee-chat-bar',
        audience: 'coffee-chat-users'
      }
    );
    
    // 6. 生成刷新Token（长期有效）
    const refreshToken = jwt.sign(
      { userId: user._id, type: 'refresh' },
      process.env.JWT_REFRESH_SECRET,
      { expiresIn: '7d' }
    );
    
    // 7. 更新用户最后登录时间
    await Users.findByIdAndUpdate(user._id, {
      lastLoginAt: new Date(),
      lastLoginIp: req.ip
    });
    
    // 8. 返回成功响应
    res.json({
      success: true,
      message: '登录成功',
      data: {
        accessToken,
        refreshToken,
        user: {
          uid: user._id,
          username: user.username,
          avatar: user.avatar,
          role: user.role
        },
        expiresIn: 900 // 15分钟
      }
    });
    
  } catch (error) {
    console.error('登录错误:', error);
    res.status(500).json({
      success: false,
      message: '服务器内部错误'
    });
  }
});
```

**2. JWT认证中间件：**
```javascript
// middlewares/auth.js - 完整的认证中间件
const jwt = require('jsonwebtoken');
const Users = require('../models/Users');

// 主要认证中间件
const authenticateToken = async (req, res, next) => {
  try {
    // 1. 获取Token
    const authHeader = req.headers['authorization'];
    const token = authHeader && authHeader.split(' ')[1]; // Bearer TOKEN
    
    if (!token) {
      return res.status(401).json({
        success: false,
        message: '访问被拒绝，缺少认证Token'
      });
    }
    
    // 2. 验证Token
    const decoded = jwt.verify(token, process.env.JWT_SECRET, {
      issuer: 'coffee-chat-bar',
      audience: 'coffee-chat-users'
    });
    
    // 3. 检查Token是否在黑名单中
    const isBlacklisted = await checkTokenBlacklist(decoded.jti);
    if (isBlacklisted) {
      return res.status(401).json({
        success: false,
        message: 'Token已失效'
      });
    }
    
    // 4. 验证用户是否仍然存在且有效
    const user = await Users.findById(decoded.userId).select('-password');
    if (!user) {
      return res.status(401).json({
        success: false,
        message: '用户不存在'
      });
    }
    
    if (user.status === 'disabled') {
      return res.status(403).json({
        success: false,
        message: '账户已被禁用'
      });
    }
    
    // 5. 检查账户是否被锁定
    if (user.lockedUntil && user.lockedUntil > new Date()) {
      return res.status(423).json({
        success: false,
        message: '账户暂时被锁定，请稍后再试'
      });
    }
    
    // 6. 将用户信息添加到请求对象
    req.user = {
      id: user._id,
      username: user.username,
      role: user.role,
      tokenPayload: decoded
    };
    
    // 7. 记录API访问日志
    logApiAccess(req, user._id);
    
    next();
    
  } catch (error) {
    if (error.name === 'TokenExpiredError') {
      return res.status(401).json({
        success: false,
        message: 'Token已过期，请重新登录',
        code: 'TOKEN_EXPIRED'
      });
    } else if (error.name === 'JsonWebTokenError') {
      return res.status(401).json({
        success: false,
        message: '无效的Token',
        code: 'INVALID_TOKEN'
      });
    } else {
      console.error('认证中间件错误:', error);
      return res.status(500).json({
        success: false,
        message: '认证服务异常'
      });
    }
  }
};

module.exports = { authenticateToken };
```

### Q11: 密码是如何加密存储的？
**A:** 使用bcrypt进行密码加密：
```javascript
// 注册时加密
const hashedPassword = await bcrypt.hash(password, saltRounds);

// 登录时验证
const isMatch = await bcrypt.compare(password, user.Password);
```
**优势**: bcrypt是专门为密码设计的哈希函数，具有自适应性，可以抵御彩虹表攻击

### Q12: 如何处理文件上传？
**A:** 实现安全的文件上传系统：

**1. 后端文件上传配置：**
```javascript
// routes/upload.js - 完整的文件上传实现
const multer = require('multer');
const path = require('path');
const crypto = require('crypto');
const sharp = require('sharp'); // 图片处理
const ffmpeg = require('fluent-ffmpeg'); // 视频处理

// 文件存储配置
const storage = multer.diskStorage({
  destination: (req, file, cb) => {
    // 根据文件类型分类存储
    let uploadPath = './uploads/';
    
    if (file.mimetype.startsWith('image/')) {
      uploadPath += 'images/';
    } else if (file.mimetype.startsWith('video/')) {
      uploadPath += 'videos/';
    } else if (file.mimetype.startsWith('audio/')) {
      uploadPath += 'audios/';
    } else {
      uploadPath += 'documents/';
    }
    
    // 按日期分目录
    const dateFolder = new Date().toISOString().split('T')[0];
    uploadPath += dateFolder + '/';
    
    // 确保目录存在
    const fs = require('fs');
    if (!fs.existsSync(uploadPath)) {
      fs.mkdirSync(uploadPath, { recursive: true });
    }
    
    cb(null, uploadPath);
  },
  
  filename: (req, file, cb) => {
    // 生成安全的文件名
    const uniqueSuffix = crypto.randomBytes(16).toString('hex');
    const timestamp = Date.now();
    const ext = path.extname(file.originalname);
    const safeName = file.originalname
      .replace(/[^a-zA-Z0-9.-]/g, '_') // 替换特殊字符
      .substring(0, 50); // 限制长度
    
    const filename = `${timestamp}_${uniqueSuffix}_${safeName}`;
    cb(null, filename);
  }
});

// 文件过滤器
const fileFilter = (req, file, cb) => {
  // 允许的文件类型
  const allowedTypes = {
    'image/jpeg': '.jpg',
    'image/png': '.png',
    'image/gif': '.gif',
    'image/webp': '.webp',
    'video/mp4': '.mp4',
    'video/webm': '.webm',
    'audio/mpeg': '.mp3',
    'audio/wav': '.wav',
    'application/pdf': '.pdf',
    'text/plain': '.txt'
  };
  
  // 检查文件类型
  if (allowedTypes[file.mimetype]) {
    cb(null, true);
  } else {
    cb(new Error(`不支持的文件类型: ${file.mimetype}`), false);
  }
};

// Multer配置
const upload = multer({
  storage: storage,
  fileFilter: fileFilter,
  limits: {
    fileSize: 50 * 1024 * 1024, // 50MB限制
    files: 5, // 最多5个文件
    fieldSize: 1024 * 1024 // 1MB字段大小限制
  }
});

// 文件上传路由
router.post('/upload', 
  authenticateToken, // 认证中间件
  upload.array('files', 5), // 支持多文件上传
  async (req, res) => {
    try {
      if (!req.files || req.files.length === 0) {
        return res.status(400).json({
          success: false,
          message: '没有上传文件'
        });
      }
      
      const uploadedFiles = [];
      
      // 处理每个上传的文件
      for (const file of req.files) {
        try {
          // 1. 病毒扫描（可选）
          await scanFileForVirus(file.path);
          
          // 2. 生成文件信息
          const fileInfo = {
            originalName: file.originalname,
            filename: file.filename,
            path: file.path,
            size: file.size,
            mimetype: file.mimetype,
            uploadedBy: req.user.id,
            uploadedAt: new Date()
          };
          
          // 3. 图片处理
          if (file.mimetype.startsWith('image/')) {
            await processImage(file, fileInfo);
          }
          
          // 4. 视频处理
          if (file.mimetype.startsWith('video/')) {
            await processVideo(file, fileInfo);
          }
          
          // 5. 保存文件记录到数据库
          const savedFile = await saveFileRecord(fileInfo);
          
          uploadedFiles.push({
            id: savedFile._id,
            filename: savedFile.filename,
            originalName: savedFile.originalName,
            size: savedFile.size,
            type: savedFile.mimetype,
            url: `/uploads/${savedFile.relativePath}`,
            thumbnail: savedFile.thumbnail
          });
          
        } catch (fileError) {
          console.error(`处理文件 ${file.originalname} 失败:`, fileError);
          // 删除失败的文件
          fs.unlinkSync(file.path);
        }
      }
      
      res.json({
        success: true,
        message: '文件上传成功',
        data: {
          files: uploadedFiles
        }
      });
      
    } catch (error) {
      console.error('文件上传错误:', error);
      res.status(500).json({
        success: false,
        message: '文件上传失败',
        error: error.message
      });
    }
  }
);
```
**静态文件服务**: `app.use('/uploads', express.static(path.join(__dirname, 'uploads')))`

---

## 数据库设计问答

### Q13: 为什么选择MongoDB而不是MySQL？
**A:** 选择MongoDB的原因：
1. **文档型数据库**: 适合存储聊天消息这种半结构化数据
2. **灵活的Schema**: 消息类型多样（文本、图片、文件），MongoDB更灵活
3. **水平扩展**: 支持分片，适合大量消息数据
4. **JSON原生支持**: 与Node.js配合更自然

### Q14: 用户模型是如何设计的？
**A:** 在`models/Users.js`中定义：
```javascript
const userSchema = new mongoose.Schema({
    uID: String,                    // 用户唯一ID
    uAvatar: {                      // 用户头像
        type: String,
        default: "/images/avatar/default-avatar.webp"
    },
    uName: String,                  // 用户名
    Password: String,               // 加密后的密码
    Friends: [{                     // 好友列表
        uID: String
    }]
})
```
**设计考虑**: 使用自定义uID而不是MongoDB的_id，便于前端处理

### Q15: 消息模型支持哪些类型？
**A:** 在`models/Messages.js`中定义：
```javascript
const msgSchema = new mongoose.Schema({
    from: String,                   // 发送者
    to: String,                     // 接收者
    time: Date,                     // 发送时间
    messageType: {                  // 消息类型
        type: String,
        enum: ['text', 'image', 'file'],
        default: 'text'
    },
    content: String,                // 文本内容或文件名
    fileInfo: {                     // 文件信息
        fileName: String,
        fileUrl: String,
        fileSize: Number,
        fileType: String,
        thumbnailUrl: String
    },
    isForwarded: Boolean,           // 是否转发消息
    forwardedFrom: String           // 转发来源
})
```
**支持类型**: 文本消息、图片消息、文件消息，并支持消息转发功能

### Q16: 数据库连接是如何配置的？
**A:** 在`config/db.js`中：
```javascript
const connectDB = async () => {
    try {
        const mongoUrl = process.env.MONGO_URL; 
        if (!mongoUrl) {
            console.error('错误: MONGO_URL 环境变量未设置!');
            process.exit(1); 
        }
        await mongoose.connect(mongoUrl);
        console.log('MongoDB 连接成功!');
    } catch (err) {
        console.error('MongoDB 连接失败:', err);
        process.exit(1);
    }
};
```
**优势**: 使用环境变量管理数据库连接，提高安全性和灵活性

---

## 实时通信问答

### Q17: 为什么选择Socket.IO而不是原生WebSocket？
**A:** Socket.IO的优势：
1. **自动降级**: 不支持WebSocket时自动使用长轮询
2. **房间管理**: 内置房间概念，便于群聊实现
3. **事件系统**: 基于事件的通信模式更清晰
4. **断线重连**: 自动处理连接断开和重连
5. **跨域支持**: 内置CORS处理

### Q18: 私聊功能是如何实现的？
**A:** 在`sockets/chat.js`中实现完整的私聊系统：

**1. 用户连接管理：**
```javascript
// sockets/chat.js - 完整的私聊实现
const jwt = require('jsonwebtoken');
const Users = require('../models/Users');
const Messages = require('../models/Messages');

// 用户连接映射表 - 支持一个用户多个连接
const userConnections = new Map(); // userId -> Set of socketIds
const socketUsers = new Map();     // socketId -> userId

// Socket.IO认证中间件
io.use(async (socket, next) => {
  try {
    // 从握手认证获取token
    const token = socket.handshake.auth.token;
    
    if (!token) {
      return next(new Error('认证失败：缺少token'));
    }
    
    // 验证JWT token
    const decoded = jwt.verify(token, process.env.JWT_SECRET);
    
    // 验证用户是否存在
    const user = await Users.findById(decoded.userId).select('-password');
    if (!user) {
      return next(new Error('认证失败：用户不存在'));
    }
    
    // 将用户信息附加到socket
    socket.userId = user._id.toString();
    socket.username = user.username;
    socket.avatar = user.avatar;
    
    next();
  } catch (error) {
    console.error('Socket认证失败:', error.message);
    next(new Error('认证失败：无效token'));
  }
});

// 处理Socket连接
io.on('connection', (socket) => {
  console.log(`用户 ${socket.username} 连接成功，Socket ID: ${socket.id}`);
  
  // 用户登录处理
  socket.on('user-login', async (data) => {
    try {
      const userId = socket.userId;
      
      // 更新用户连接映射
      if (!userConnections.has(userId)) {
        userConnections.set(userId, new Set());
      }
      userConnections.get(userId).add(socket.id);
      socketUsers.set(socket.id, userId);
      
      // 加入用户专属房间
      socket.join(`user_${userId}`);
      
      // 更新用户在线状态
      await Users.findByIdAndUpdate(userId, {
        isOnline: true,
        lastSeenAt: new Date()
      });
      
      // 通知好友用户上线
      const user = await Users.findById(userId).populate('friends', 'username avatar isOnline');
      user.friends.forEach(friend => {
        socket.to(`user_${friend._id}`).emit('friend-online', {
          userId: userId,
          username: socket.username,
          avatar: socket.avatar,
          timestamp: new Date()
        });
      });
      
      console.log(`用户 ${socket.username} 登录成功，当前连接数: ${userConnections.get(userId).size}`);
      
    } catch (error) {
      console.error('用户登录处理失败:', error);
      socket.emit('error', { message: '登录处理失败' });
    }
  });
  
  // 私聊消息处理
  socket.on('private-message', async (data) => {
    try {
      const { receiverId, content, type = 'text', fileInfo = null } = data;
      const senderId = socket.userId;
      
      // 输入验证
      if (!receiverId || !content) {
        return socket.emit('message-error', {
          error: '消息内容不能为空'
        });
      }
      
      // 验证接收者是否存在
      const receiver = await Users.findById(receiverId);
      if (!receiver) {
        return socket.emit('message-error', {
          error: '接收者不存在'
        });
      }
      
      // 检查是否为好友关系
      const sender = await Users.findById(senderId);
      if (!sender.friends.includes(receiverId)) {
        return socket.emit('message-error', {
          error: '只能向好友发送消息'
        });
      }
      
      // 创建消息对象
      const messageData = {
        senderId,
        receiverId,
        content,
        type,
        timestamp: new Date(),
        messageId: generateMessageId(),
        status: 'sent'
      };
      
      // 处理文件消息
      if (type !== 'text' && fileInfo) {
        messageData.fileInfo = {
          filename: fileInfo.filename,
          originalName: fileInfo.originalName,
          size: fileInfo.size,
          type: fileInfo.type,
          url: fileInfo.url,
          thumbnail: fileInfo.thumbnail
        };
      }
      
      // 保存消息到数据库
      const savedMessage = await Messages.create(messageData);
      
      // 构建发送给客户端的消息
      const clientMessage = {
        messageId: messageData.messageId,
        senderId,
        senderName: socket.username,
        senderAvatar: socket.avatar,
        receiverId,
        content,
        type,
        timestamp: messageData.timestamp,
        fileInfo: messageData.fileInfo,
        status: 'delivered'
      };
      
      // 发送给接收者（所有连接）
      const receiverConnections = userConnections.get(receiverId);
      if (receiverConnections && receiverConnections.size > 0) {
        // 用户在线，直接发送
        io.to(`user_${receiverId}`).emit('receive-message', clientMessage);
        
        // 更新消息状态为已送达
        await Messages.findByIdAndUpdate(savedMessage._id, {
          status: 'delivered',
          deliveredAt: new Date()
        });
        
        console.log(`消息已发送给在线用户 ${receiverId}`);
      } else {
        // 用户离线，消息将在用户上线时发送
        console.log(`用户 ${receiverId} 离线，消息已保存`);
      }
      
      // 确认消息发送成功给发送者
      socket.emit('message-sent', {
        messageId: messageData.messageId,
        timestamp: messageData.timestamp,
        status: receiverConnections ? 'delivered' : 'sent'
      });
      
    } catch (error) {
      console.error('私聊消息处理失败:', error);
      socket.emit('message-error', {
        error: '消息发送失败',
        details: error.message
      });
    }
  });
  
  // 消息已读回执
  socket.on('message-read', async (data) => {
    try {
      const { messageId, senderId } = data;
      const readerId = socket.userId;
      
      // 更新消息状态
      await Messages.findOneAndUpdate(
        { messageId, receiverId: readerId },
        { 
          status: 'read',
          readAt: new Date()
        }
      );
      
      // 通知发送者消息已读
      io.to(`user_${senderId}`).emit('message-read-receipt', {
        messageId,
        readBy: readerId,
        readAt: new Date()
      });
      
    } catch (error) {
      console.error('消息已读处理失败:', error);
    }
  });
  
  // 正在输入状态
  socket.on('typing-start', (data) => {
    const { receiverId } = data;
    socket.to(`user_${receiverId}`).emit('user-typing', {
      userId: socket.userId,
      username: socket.username,
      isTyping: true
    });
  });
  
  socket.on('typing-stop', (data) => {
    const { receiverId } = data;
    socket.to(`user_${receiverId}`).emit('user-typing', {
      userId: socket.userId,
      username: socket.username,
      isTyping: false
    });
  });
});

// 生成唯一消息ID
function generateMessageId() {
  return `msg_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
}
```
**关键设计**: 
1. 支持一个用户多个连接（多设备登录）
2. JWT认证确保连接安全
3. 消息状态跟踪（发送、送达、已读）
4. 好友关系验证
5. 实时输入状态提示

### Q18.1: Socket.IO如何处理高并发连接？
**A:** 实施多重性能优化策略：

**1. 连接池和负载均衡：**
```javascript
// server.js - Socket.IO集群配置
const cluster = require('cluster');
const numCPUs = require('os').cpus().length;
const { createAdapter } = require('@socket.io/redis-adapter');
const redis = require('redis');

if (cluster.isMaster) {
  console.log(`主进程 ${process.pid} 正在运行`);
  
  // 创建工作进程
  for (let i = 0; i < numCPUs; i++) {
    cluster.fork();
  }
  
  cluster.on('exit', (worker, code, signal) => {
    console.log(`工作进程 ${worker.process.pid} 已退出`);
    cluster.fork(); // 重启工作进程
  });
  
} else {
  // 工作进程
  const io = new Server(server, {
    cors: { origin: "*" },
    transports: ['websocket', 'polling'],
    
    // 性能优化配置
    pingTimeout: 60000,        // 心跳超时时间
    pingInterval: 25000,       // 心跳间隔
    upgradeTimeout: 10000,     // 升级超时
    maxHttpBufferSize: 1e6,    // 最大HTTP缓冲区大小 1MB
    
    // 压缩配置
    compression: true,
    perMessageDeflate: {
      threshold: 1024,         // 压缩阈值
      concurrencyLimit: 10,    // 并发限制
      memLevel: 7              // 内存级别
    }
  });
  
  // Redis适配器用于多进程通信
  const pubClient = redis.createClient({
    host: process.env.REDIS_HOST || 'localhost',
    port: process.env.REDIS_PORT || 6379
  });
  
  const subClient = pubClient.duplicate();
  io.adapter(createAdapter(pubClient, subClient));
  
  // 连接限制中间件
  io.use((socket, next) => {
    const clientsCount = io.engine.clientsCount;
    const maxConnections = process.env.MAX_CONNECTIONS || 1000;
    
    if (clientsCount >= maxConnections) {
      return next(new Error('服务器连接数已满'));
    }
    
    next();
  });
  
  console.log(`工作进程 ${process.pid} 已启动`);
}
```

**2. 消息队列和批处理：**
```javascript
// utils/messageQueue.js - 消息队列管理
class MessageQueue {
  constructor() {
    this.queues = new Map();     // userId -> messages[]
    this.batchSize = 10;         // 批处理大小
    this.flushInterval = 1000;   // 刷新间隔 1秒
    this.processing = false;
    
    // 定时刷新队列
    setInterval(() => {
      this.flushAllQueues();
    }, this.flushInterval);
  }
  
  // 添加消息到队列
  enqueue(userId, message) {
    if (!this.queues.has(userId)) {
      this.queues.set(userId, []);
    }
    
    const userQueue = this.queues.get(userId);
    userQueue.push(message);
    
    // 如果队列达到批处理大小，立即处理
    if (userQueue.length >= this.batchSize) {
      this.flushQueue(userId);
    }
  }
  
  // 刷新指定用户的队列
  flushQueue(userId) {
    const userQueue = this.queues.get(userId);
    if (!userQueue || userQueue.length === 0) {
      return;
    }
    
    // 批量发送消息
    const messages = userQueue.splice(0, this.batchSize);
    
    io.to(`user_${userId}`).emit('batch-messages', {
      messages,
      count: messages.length,
      timestamp: new Date()
    });
    
    console.log(`批量发送 ${messages.length} 条消息给用户 ${userId}`);
  }
}

const messageQueue = new MessageQueue();
export default messageQueue;
```

### Q18.2: Socket.IO的安全性如何保障？
**A:** 实施多层安全防护：

**1. 连接认证和授权：**
```javascript
// 安全中间件
io.use(async (socket, next) => {
  try {
    // 1. IP白名单检查
    const clientIp = socket.handshake.address;
    if (!await isIPAllowed(clientIp)) {
      return next(new Error('IP地址不在白名单中'));
    }
    
    // 2. Token验证
    const token = socket.handshake.auth.token;
    if (!token) {
      return next(new Error('缺少认证token'));
    }
    
    const decoded = jwt.verify(token, process.env.JWT_SECRET);
    
    // 3. 用户状态检查
    const user = await Users.findById(decoded.userId);
    if (!user || user.status !== 'active') {
      return next(new Error('用户账户异常'));
    }
    
    // 4. 设备指纹验证
    const deviceFingerprint = generateDeviceFingerprint(socket.handshake);
    if (!await validateDeviceFingerprint(decoded.userId, deviceFingerprint)) {
      // 记录可疑登录
      await logSuspiciousActivity(decoded.userId, {
        type: 'unknown_device',
        ip: clientIp,
        userAgent: socket.handshake.headers['user-agent'],
        fingerprint: deviceFingerprint
      });
      
      return next(new Error('设备验证失败'));
    }
    
    // 5. 并发连接限制
    const userConnections = getUserConnections(decoded.userId);
    if (userConnections.length >= 5) { // 最多5个并发连接
      return next(new Error('超过最大连接数限制'));
    }
    
    socket.userId = decoded.userId;
    socket.deviceFingerprint = deviceFingerprint;
    
    next();
    
  } catch (error) {
    console.error('Socket认证失败:', error);
    next(new Error('认证失败'));
  }
});

// 生成设备指纹
function generateDeviceFingerprint(handshake) {
  const crypto = require('crypto');
  
  const components = [
    handshake.headers['user-agent'] || '',
    handshake.headers['accept-language'] || '',
    handshake.address,
    handshake.headers['sec-ch-ua'] || ''
  ];
  
  return crypto
    .createHash('sha256')
    .update(components.join('|'))
    .digest('hex');
}
```

**2. 速率限制和防护：**
```javascript
// 速率限制中间件
const rateLimiter = new Map();

io.use((socket, next) => {
  const clientIp = socket.handshake.address;
  const now = Date.now();
  const windowMs = 60000;      // 1分钟窗口
  const maxRequests = 100;     // 最大请求数
  
  if (!rateLimiter.has(clientIp)) {
    rateLimiter.set(clientIp, { count: 1, resetTime: now + windowMs });
    return next();
  }
  
  const clientData = rateLimiter.get(clientIp);
  
  if (now > clientData.resetTime) {
    // 重置计数器
    clientData.count = 1;
    clientData.resetTime = now + windowMs;
  } else {
    clientData.count++;
    
    if (clientData.count > maxRequests) {
      return next(new Error('请求频率过高'));
    }
  }
  
  next();
});

// 消息内容过滤
socket.on('private-message', async (data) => {
  try {
    // 1. 内容长度限制
    if (data.content && data.content.length > 5000) {
      return socket.emit('message-error', {
        error: '消息内容过长'
      });
    }
    
    // 2. 敏感词过滤
    const filteredContent = await filterSensitiveWords(data.content);
    if (filteredContent !== data.content) {
      data.content = filteredContent;
      
      // 记录敏感词使用
      await logSensitiveWordUsage(socket.userId, data.content);
    }
    
    // 3. 垃圾信息检测
    const isSpam = await detectSpam(data.content, socket.userId);
    if (isSpam) {
      return socket.emit('message-error', {
        error: '消息被识别为垃圾信息'
      });
    }
    
    // 继续处理消息...
    
  } catch (error) {
    console.error('消息处理失败:', error);
  }
});
```

### Q19: 如何处理用户断线重连？
**A:** 实现智能重连机制和连接状态管理：

**1. 后端断线处理：**
```javascript
// sockets/chat.js - 断线连接清理
socket.on('disconnect', async (reason) => {
  try {
    const userId = socketUsers.get(socket.id);
    if (userId) {
      // 从连接映射中移除
      const connections = userConnections.get(userId);
      if (connections) {
        connections.delete(socket.id);
        
        // 如果用户没有其他连接，标记为离线
        if (connections.size === 0) {
          userConnections.delete(userId);
          
          // 更新用户离线状态
          await Users.findByIdAndUpdate(userId, {
            isOnline: false,
            lastSeenAt: new Date()
          });
          
          // 通知好友用户离线
          const user = await Users.findById(userId).populate('friends');
          user.friends.forEach(friend => {
            io.to(`user_${friend._id}`).emit('friend-offline', {
              userId: userId,
              username: socket.username,
              lastSeenAt: new Date()
            });
          });
        }
      }
      
      socketUsers.delete(socket.id);
    }
    
    console.log(`用户 ${socket.username} 断开连接，原因: ${reason}`);
    
  } catch (error) {
    console.error('断开连接处理失败:', error);
  }
});

// 发送离线消息
async function sendOfflineMessages(socket, userId) {
  try {
    // 获取用户离线期间的消息
    const user = await Users.findById(userId);
    const lastSeenAt = user.lastSeenAt || new Date(0);
    
    const offlineMessages = await Messages.find({
      receiverId: userId,
      timestamp: { $gt: lastSeenAt },
      status: { $ne: 'recalled' }
    })
    .populate('senderId', 'username avatar')
    .sort({ timestamp: 1 })
    .limit(100); // 限制离线消息数量
    
    if (offlineMessages.length > 0) {
      // 批量发送离线消息
      socket.emit('offline-messages', {
        messages: offlineMessages.map(msg => ({
          messageId: msg.messageId,
          senderId: msg.senderId._id,
          senderName: msg.senderId.username,
          senderAvatar: msg.senderId.avatar,
          content: msg.content,
          type: msg.type,
          timestamp: msg.timestamp,
          fileInfo: msg.fileInfo
        })),
        count: offlineMessages.length
      });
      
      console.log(`发送 ${offlineMessages.length} 条离线消息给用户 ${userId}`);
    }
  } catch (error) {
    console.error('发送离线消息失败:', error);
  }
}
```

**2. 前端重连管理器：**
```javascript
// utils/socketManager.js - 前端Socket管理器
import { io } from 'socket.io-client';
import { useRouter } from 'vue-router';
import { useChatStore } from '@/stores/useChatStore';

class SocketManager {
  constructor() {
    this.socket = null;
    this.reconnectAttempts = 0;
    this.maxReconnectAttempts = 10;
    this.baseDelay = 1000;
    this.maxDelay = 30000;
    this.backoffFactor = 1.5;
    this.jitterFactor = 0.1;
    this.isReconnecting = false;
    this.messageQueue = []; // 离线消息队列
    this.eventHandlers = new Map(); // 事件处理器映射
  }
  
  // 初始化Socket连接
  async connect() {
    if (this.isConnecting || (this.socket && this.socket.connected)) {
      return this.socket;
    }
    
    this.isConnecting = true;
    
    try {
      const token = localStorage.getItem('accessToken');
      if (!token) {
        throw new Error('没有认证token');
      }
      
      // 创建Socket连接
      this.socket = io(import.meta.env.VITE_BASE_URL, {
        auth: { token }, // 认证token
        transports: ['websocket', 'polling'], // 传输方式
        timeout: 10000, // 连接超时
        reconnection: true, // 自动重连
        reconnectionAttempts: this.maxReconnectAttempts,
        reconnectionDelay: this.baseDelay,
        reconnectionDelayMax: this.maxDelay,
        maxReconnectionAttempts: this.maxReconnectAttempts,
        randomizationFactor: this.jitterFactor
      });
      
      this.setupEventListeners();
      
      // 等待连接成功
      await this.waitForConnection();
      
      return this.socket;
      
    } catch (error) {
      console.error('Socket连接失败:', error);
      this.isConnecting = false;
      throw error;
    }
  }
  
  // 等待连接成功
  waitForConnection() {
    return new Promise((resolve, reject) => {
      const timeout = setTimeout(() => {
        reject(new Error('连接超时'));
      }, 10000);
      
      this.socket.on('connect', () => {
        clearTimeout(timeout);
        this.isConnecting = false;
        this.reconnectAttempts = 0;
        console.log('Socket连接成功:', this.socket.id);
        
        // 发送用户登录事件
        this.emitUserLogin();
        
        // 处理离线消息队列
        this.processMessageQueue();
        
        resolve(this.socket);
      });
      
      this.socket.on('connect_error', (error) => {
        clearTimeout(timeout);
        this.isConnecting = false;
        console.error('Socket连接错误:', error.message);
        reject(error);
      });
    });
  }
  
  // 设置事件监听器
  setupEventListeners() {
    const chatStore = useChatStore();
    
    // 连接成功
    this.socket.on('connect', () => {
      console.log('Socket重新连接成功');
      this.reconnectAttempts = 0;
      this.hideReconnectionStatus();
    });
    
    // 连接错误
    this.socket.on('connect_error', (error) => {
      console.error('Socket连接错误:', error.message);
      this.handleReconnect();
    });
    
    // 断开连接
    this.socket.on('disconnect', (reason) => {
      console.log('Socket连接断开:', reason);
      
      if (reason === 'io server disconnect') {
        // 服务器主动断开，需要重新连接
        this.handleReconnect();
      }
    });
    
    // 接收消息
    this.socket.on('receive-message', (data) => {
      console.log('收到新消息:', data);
      
      // 添加到聊天store
      chatStore.addMessage(data);
      
      // 显示桌面通知
      this.showDesktopNotification(data);
      
      // 播放提示音
      this.playNotificationSound();
      
      // 发送已读回执（如果当前聊天窗口是发送者）
      if (chatStore.currentChatUser === data.senderId) {
        this.markMessageAsRead(data.messageId, data.senderId);
      }
    });
    
    // 离线消息
    this.socket.on('offline-messages', (data) => {
      console.log(`收到 ${data.count} 条离线消息`);
      
      data.messages.forEach(message => {
        chatStore.addMessage(message);
      });
      
      // 显示离线消息提示
      this.showOfflineMessageNotification(data.count);
    });
    
    // 消息发送确认
    this.socket.on('message-sent', (data) => {
      console.log('消息发送确认:', data);
      chatStore.updateMessageStatus(data.messageId, data.status);
    });
    
    // 消息已读回执
    this.socket.on('message-read-receipt', (data) => {
      console.log('消息已读回执:', data);
      chatStore.updateMessageStatus(data.messageId, 'read');
    });
    
    // 消息撤回
    this.socket.on('message-recalled', (data) => {
      console.log('消息被撤回:', data);
      chatStore.recallMessage(data.messageId);
    });
    
    // 好友上线
    this.socket.on('friend-online', (data) => {
      console.log('好友上线:', data.username);
      chatStore.updateFriendStatus(data.userId, true);
    });
    
    // 好友离线
    this.socket.on('friend-offline', (data) => {
      console.log('好友离线:', data.username);
      chatStore.updateFriendStatus(data.userId, false, data.lastSeenAt);
    });
    
    // 正在输入
    this.socket.on('user-typing', (data) => {
      chatStore.updateTypingStatus(data.userId, data.isTyping);
    });
    
    // 错误处理
    this.socket.on('error', (error) => {
      console.error('Socket错误:', error);
      this.handleSocketError(error);
    });
    
    this.socket.on('message-error', (error) => {
      console.error('消息错误:', error);
      // 显示错误提示
      ElMessage.error(error.error || '消息发送失败');
    });
  }
  
  // 处理重连
  handleReconnect() {
    if (this.isReconnecting) return;
    
    this.isReconnecting = true;
    this.attemptReconnection();
  }
  
  // 尝试重连
  async attemptReconnection() {
    if (this.reconnectAttempts >= this.maxReconnectAttempts) {
      console.error('达到最大重连次数，停止重连');
      this.handleReconnectionFailure();
      return;
    }
    
    this.reconnectAttempts++;
    
    // 计算延迟时间（指数退避 + 抖动）
    const baseDelay = Math.min(
      this.baseDelay * Math.pow(this.backoffFactor, this.reconnectAttempts - 1),
      this.maxDelay
    );
    
    const jitter = baseDelay * this.jitterFactor * Math.random();
    const delay = baseDelay + jitter;
    
    console.log(`重连尝试 ${this.reconnectAttempts}/${this.maxReconnectAttempts}，${Math.round(delay)}ms后重试`);
    
    // 显示重连状态
    this.showReconnectionStatus(this.reconnectAttempts, delay);
    
    setTimeout(async () => {
      try {
        // 检查网络状态
        if (!navigator.onLine) {
          console.log('网络离线，等待网络恢复');
          this.waitForOnline();
          return;
        }
        
        // 尝试重新连接
        await this.connect();
        
        // 重连成功
        this.handleReconnectionSuccess();
        
      } catch (error) {
        console.error('重连失败:', error);
        
        // 继续尝试重连
        this.attemptReconnection();
      }
    }, delay);
  }
  
  // 等待网络恢复
  waitForOnline() {
    const handleOnline = () => {
      console.log('网络已恢复，继续重连');
      window.removeEventListener('online', handleOnline);
      this.attemptReconnection();
    };
    
    window.addEventListener('online', handleOnline);
  }
  
  // 重连成功处理
  handleReconnectionSuccess() {
    console.log('重连成功');
    
    this.reconnectAttempts = 0;
    this.isReconnecting = false;
    
    // 隐藏重连状态
    this.hideReconnectionStatus();
    
    // 重新同步数据
    this.resyncData();
  }
  
  // 重连失败处理
  handleReconnectionFailure() {
    this.isReconnecting = false;
    
    // 显示错误提示
    ElMessage.error({
      message: '连接失败，请检查网络后刷新页面',
      duration: 0,
      showClose: true
    });
  }
  
  // 显示重连状态
  showReconnectionStatus(attempt, delay) {
    // 创建或更新重连提示
    let notification = document.getElementById('reconnection-notification');
    
    if (!notification) {
      notification = document.createElement('div');
      notification.id = 'reconnection-notification';
      notification.style.cssText = `
        position: fixed;
        top: 20px;
        right: 20px;
        background: #f56c6c;
        color: white;
        padding: 12px 20px;
        border-radius: 4px;
        z-index: 9999;
        font-size: 14px;
      `;
      document.body.appendChild(notification);
    }
    
    notification.textContent = `连接断开，正在重连... (${attempt}/${this.maxReconnectAttempts})`;
  }
  
  // 隐藏重连状态
  hideReconnectionStatus() {
    const notification = document.getElementById('reconnection-notification');
    if (notification) {
      notification.remove();
    }
  }
  
  // 处理离线消息队列
  processMessageQueue() {
    if (this.messageQueue.length > 0) {
      console.log(`处理 ${this.messageQueue.length} 条离线消息`);
      
      this.messageQueue.forEach(item => {
        this.socket.emit(item.event, item.data);
      });
      
      this.messageQueue = [];
    }
  }
  
  // 发送私聊消息
  sendPrivateMessage(receiverId, content, type = 'text', fileInfo = null) {
    const messageData = {
      receiverId,
      content,
      type,
      fileInfo,
      timestamp: new Date()
    };
    
    if (this.socket && this.socket.connected) {
      this.socket.emit('private-message', messageData);
    } else {
      // 连接断开时，将消息加入队列
      this.messageQueue.push({
        event: 'private-message',
        data: messageData
      });
      
      // 尝试重连
      this.handleReconnect();
    }
  }
  
  // 显示桌面通知
  showDesktopNotification(message) {
    if ('Notification' in window && Notification.permission === 'granted') {
      new Notification(`来自 ${message.senderName} 的消息`, {
        body: message.type === 'text' ? message.content : `[${message.type}]`,
        icon: message.senderAvatar || '/default-avatar.png',
        tag: message.senderId // 防止重复通知
      });
    }
  }
  
  // 播放提示音
  playNotificationSound() {
    const audio = new Audio('/notification.mp3');
    audio.volume = 0.5;
    audio.play().catch(error => {
      console.log('无法播放提示音:', error);
    });
  }
  
  // 断开连接
  disconnect() {
    if (this.socket) {
      this.socket.disconnect();
      this.socket = null;
    }
    this.reconnectAttempts = 0;
    this.messageQueue = [];
  }
}

// 导出单例
export const socketManager = new SocketManager();
export default socketManager;
```

### Q19.1: 如何处理网络波动和弱网环境？
**A:** 实现网络自适应策略：

```javascript
// utils/networkMonitor.js - 网络监控器
class NetworkMonitor {
  constructor() {
    this.connection = navigator.connection || navigator.mozConnection || navigator.webkitConnection;
    this.isOnline = navigator.onLine;
    this.networkQuality = 'good';
    this.listeners = new Set();
    
    this.setupEventListeners();
    this.startNetworkQualityMonitoring();
  }
  
  // 设置网络事件监听
  setupEventListeners() {
    // 在线/离线状态监听
    window.addEventListener('online', () => {
      this.isOnline = true;
      this.notifyListeners('online');
    });
    
    window.addEventListener('offline', () => {
      this.isOnline = false;
      this.notifyListeners('offline');
    });
    
    // 网络连接变化监听
    if (this.connection) {
      this.connection.addEventListener('change', () => {
        this.evaluateNetworkQuality();
        this.notifyListeners('change', this.getNetworkInfo());
      });
    }
  }
  
  // 评估网络质量
  evaluateNetworkQuality() {
    if (!this.connection) {
      this.networkQuality = 'unknown';
      return;
    }
    
    const { effectiveType, downlink, rtt } = this.connection;
    
    // 根据网络类型和指标评估质量
    if (effectiveType === '4g' && downlink > 1.5 && rtt < 150) {
      this.networkQuality = 'excellent';
    } else if (effectiveType === '4g' && downlink > 0.5 && rtt < 300) {
      this.networkQuality = 'good';
    } else if (effectiveType === '3g' || (downlink > 0.1 && rtt < 500)) {
      this.networkQuality = 'fair';
    } else {
      this.networkQuality = 'poor';
    }
  }
  
  // 获取网络信息
  getNetworkInfo() {
    return {
      isOnline: this.isOnline,
      quality: this.networkQuality,
      effectiveType: this.connection?.effectiveType,
      downlink: this.connection?.downlink,
      rtt: this.connection?.rtt,
      saveData: this.connection?.saveData
    };
  }
  
  // 根据网络质量调整Socket配置
  getOptimalSocketConfig() {
    const baseConfig = {
      transports: ['websocket', 'polling'],
      upgrade: true,
      rememberUpgrade: true
    };
    
    switch (this.networkQuality) {
      case 'excellent':
        return {
          ...baseConfig,
          timeout: 5000,
          reconnectionDelay: 1000,
          reconnectionDelayMax: 5000
        };
        
      case 'good':
        return {
          ...baseConfig,
          timeout: 8000,
          reconnectionDelay: 2000,
          reconnectionDelayMax: 10000
        };
        
      case 'fair':
        return {
          ...baseConfig,
          timeout: 15000,
          reconnectionDelay: 3000,
          reconnectionDelayMax: 15000,
          transports: ['polling', 'websocket'] // 优先使用polling
        };
        
      case 'poor':
        return {
          ...baseConfig,
          timeout: 30000,
          reconnectionDelay: 5000,
          reconnectionDelayMax: 30000,
          transports: ['polling'], // 只使用polling
          upgrade: false
        };
        
      default:
        return baseConfig;
    }
  }
  
  // 添加网络状态监听器
  addListener(callback) {
    this.listeners.add(callback);
  }
  
  // 移除监听器
  removeListener(callback) {
    this.listeners.delete(callback);
  }
  
  // 通知监听器
  notifyListeners(event, data) {
    this.listeners.forEach(callback => {
      try {
        callback(event, data);
      } catch (error) {
        console.error('网络监听器回调错误:', error);
      }
    });
  }
}

// 导出单例
export const networkMonitor = new NetworkMonitor();
export default networkMonitor;
```

### Q20: 文件消息是如何通过Socket传输的？
**A:** 实现文件消息推送：
```javascript
socket.on("private-file-message", async ({ to, fileUrl, fileName, fileType, messageType }) => {
    const targetSockets = users.get(to);
    if (targetSockets && targetSockets.size > 0) {
        targetSockets.forEach(socketId => {
            io.to(socketId).emit("private-file-message", {
                from: socket.userId,
                fileUrl,
                fileName,
                fileType,
                messageType
            });
        })
    }
});
```
**设计思路**: 文件先上传到服务器，然后通过Socket传输文件URL和元信息

---

## 前后端交互问答

### Q21: 前端如何与后端API交互？
**A:** 项目采用RESTful API + WebSocket双重通信模式：

**RESTful API处理：**
```javascript
// Login.vue中的登录请求 - 详细实现
const login = async () => {
  try {
    // 1. 前端数据验证
    if (!username.value || !password.value) {
      throw new Error('用户名和密码不能为空');
    }
    
    // 2. 发送登录请求
    const response = await axios.post(`${import.meta.env.VITE_BASE_URL}/user/login`, {
      username: username.value,
      password: password.value
    }, {
      timeout: 10000, // 10秒超时
      headers: {
        'Content-Type': 'application/json'
      }
    });
    
    // 3. 处理响应数据
    if (response.data.token) {
      // 存储认证信息
      localStorage.setItem('token', response.data.token);
      localStorage.setItem('userInfo', JSON.stringify(response.data.user));
      
      // 设置axios默认请求头
      axios.defaults.headers.common['Authorization'] = `Bearer ${response.data.token}`;
      
      // 跳转到主页
      router.push('/');
    }
  } catch (error) {
    // 详细错误处理
    if (error.response) {
      // 服务器响应错误
      const status = error.response.status;
      const message = error.response.data?.message || '登录失败';
      
      switch (status) {
        case 401:
          console.error('认证失败:', message);
          break;
        case 429:
          console.error('请求过于频繁，请稍后再试');
          break;
        case 500:
          console.error('服务器内部错误');
          break;
        default:
          console.error('登录失败:', message);
      }
    } else if (error.request) {
      // 网络错误
      console.error('网络连接失败，请检查网络设置');
    } else {
      // 其他错误
      console.error('登录失败:', error.message);
    }
  }
};
```

**WebSocket实时通信：**
```javascript
// utils/socket.js - Socket连接管理
import { io } from 'socket.io-client';

class SocketManager {
  constructor() {
    this.socket = null;
    this.reconnectAttempts = 0;
    this.maxReconnectAttempts = 5;
    this.reconnectDelay = 1000;
  }
  
  // 初始化Socket连接
  connect() {
    this.socket = io(`${import.meta.env.VITE_BASE_URL}`, {
      transports: ['websocket', 'polling'], // 传输方式
      timeout: 5000, // 连接超时
      reconnection: true, // 自动重连
      reconnectionAttempts: this.maxReconnectAttempts,
      reconnectionDelay: this.reconnectDelay,
      auth: {
        token: localStorage.getItem('token') // 认证token
      }
    });
    
    this.setupEventListeners();
    return this.socket;
  }
  
  // 设置事件监听器
  setupEventListeners() {
    // 连接成功
    this.socket.on('connect', () => {
      console.log('Socket连接成功:', this.socket.id);
      this.reconnectAttempts = 0;
      
      // 发送用户登录事件
      const userInfo = JSON.parse(localStorage.getItem('userInfo') || '{}');
      this.socket.emit('user-login', {
        userId: userInfo.uid,
        username: userInfo.username
      });
    });
    
    // 连接失败
    this.socket.on('connect_error', (error) => {
      console.error('Socket连接失败:', error.message);
      this.handleReconnect();
    });
    
    // 断开连接
    this.socket.on('disconnect', (reason) => {
      console.log('Socket连接断开:', reason);
      if (reason === 'io server disconnect') {
        // 服务器主动断开，需要重新连接
        this.socket.connect();
      }
    });
  }
  
  // 处理重连逻辑
  handleReconnect() {
    if (this.reconnectAttempts < this.maxReconnectAttempts) {
      this.reconnectAttempts++;
      console.log(`尝试重连 (${this.reconnectAttempts}/${this.maxReconnectAttempts})`);
      
      setTimeout(() => {
        this.socket.connect();
      }, this.reconnectDelay * this.reconnectAttempts);
    } else {
      console.error('重连失败，请刷新页面');
    }
  }
  
  // 发送消息
  sendMessage(event, data) {
    if (this.socket && this.socket.connected) {
      this.socket.emit(event, data);
    } else {
      console.error('Socket未连接，无法发送消息');
    }
  }
  
  // 监听消息
  onMessage(event, callback) {
    if (this.socket) {
      this.socket.on(event, callback);
    }
  }
  
  // 断开连接
  disconnect() {
    if (this.socket) {
      this.socket.disconnect();
      this.socket = null;
    }
  }
}

// 导出单例实例
export const socketManager = new SocketManager();
export default socketManager;
```

### Q21.1: 为什么选择这种双重通信模式？
**A:** 
- **RESTful API**: 适合一次性数据获取、用户认证、文件上传等操作
- **WebSocket**: 适合实时消息推送、在线状态同步、打字状态等
- **性能考虑**: HTTP请求有缓存机制，WebSocket保持长连接减少握手开销
- **可靠性**: HTTP请求更稳定，WebSocket提供实时性

### Q21.2: 如何处理API请求的错误重试机制？
**A:** 实现智能重试策略：
```javascript
// utils/apiClient.js - API客户端封装
class ApiClient {
  constructor() {
    this.maxRetries = 3;
    this.retryDelay = 1000;
    this.setupInterceptors();
  }
  
  // 设置请求拦截器
  setupInterceptors() {
    // 请求拦截器
    axios.interceptors.request.use(
      (config) => {
        // 添加认证头
        const token = localStorage.getItem('token');
        if (token) {
          config.headers.Authorization = `Bearer ${token}`;
        }
        
        // 添加请求时间戳
        config.metadata = { startTime: new Date() };
        return config;
      },
      (error) => Promise.reject(error)
    );
    
    // 响应拦截器
    axios.interceptors.response.use(
      (response) => {
        // 计算请求耗时
        const endTime = new Date();
        const duration = endTime - response.config.metadata.startTime;
        console.log(`API请求耗时: ${duration}ms`);
        
        return response;
      },
      async (error) => {
        const originalRequest = error.config;
        
        // 避免无限重试
        if (!originalRequest._retry) {
          originalRequest._retry = true;
          originalRequest._retryCount = 0;
        }
        
        // 处理token过期
        if (error.response?.status === 401 && !originalRequest._retry) {
          localStorage.removeItem('token');
          localStorage.removeItem('userInfo');
          window.location.href = '/login';
          return Promise.reject(error);
        }
        
        // 处理网络错误重试
        if (this.shouldRetry(error) && originalRequest._retryCount < this.maxRetries) {
          originalRequest._retryCount++;
          
          const delay = this.retryDelay * Math.pow(2, originalRequest._retryCount - 1);
          console.log(`API请求重试 ${originalRequest._retryCount}/${this.maxRetries}，${delay}ms后重试`);
          
          await this.sleep(delay);
          return axios(originalRequest);
        }
        
        return Promise.reject(error);
      }
    );
  }
  
  // 判断是否应该重试
  shouldRetry(error) {
    // 网络错误或5xx服务器错误才重试
    return !error.response || (error.response.status >= 500 && error.response.status < 600);
  }
  
  // 延迟函数
  sleep(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
}

export const apiClient = new ApiClient();
```

### Q22: 如何处理API请求的认证？
**A:** 在请求头中携带JWT Token：
```javascript
// 设置Axios拦截器
axios.interceptors.request.use(config => {
  const token = localStorage.getItem('token')
  if (token) {
    config.headers.Authorization = `Bearer ${token}`
  }
  return config
})
```

### Q23: Socket.IO客户端是如何初始化的？
**A:** 在`utils/socket.js`中：
```javascript
import { io } from "socket.io-client";

const socket = io(`${import.meta.env.VITE_BASE_URL}`);

function waitForSocketConnection(callback) {
  if (socket.connected) {
    callback();
  } else {
    socket.on("connect", () => {
      callback();
    });
  }
}

export { socket, waitForSocketConnection };
```
**环境变量**: 使用`VITE_BASE_URL`环境变量配置服务器地址

### Q24: 如何处理跨域问题？
**A:** 采用多层跨域解决方案：

**1. 后端CORS配置：**
```javascript
// server.js - 生产级CORS配置
const cors = require('cors');

// 环境相关的CORS配置
const corsOptions = {
  origin: function (origin, callback) {
    // 允许的域名列表
    const allowedOrigins = [
      'http://localhost:5173',    // Vite开发服务器
      'http://127.0.0.1:5173',   // 本地IP
      'https://yourdomain.com',   // 生产域名
      'file://'                   // Electron应用
    ];
    
    // 开发环境允许无origin（如Postman测试）
    if (process.env.NODE_ENV === 'development' && !origin) {
      return callback(null, true);
    }
    
    // 检查origin是否在允许列表中
    if (allowedOrigins.includes(origin)) {
      callback(null, true);
    } else {
      console.error(`CORS错误: 不允许的源 ${origin}`);
      callback(new Error('CORS policy violation'));
    }
  },
  credentials: true,              // 允许携带认证信息
  methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS', 'PATCH'],
  allowedHeaders: [
    'Origin',
    'X-Requested-With', 
    'Content-Type', 
    'Accept',
    'Authorization',
    'Cache-Control'
  ],
  exposedHeaders: ['Authorization'], // 暴露给前端的响应头
  maxAge: 86400                     // 预检请求缓存时间（24小时）
};

app.use(cors(corsOptions));

// Socket.IO CORS配置
const io = new Server(server, {
  cors: {
    origin: corsOptions.origin,
    methods: ['GET', 'POST'],
    credentials: true,
    allowEIO3: true // 兼容旧版本
  },
  transports: ['websocket', 'polling'],
  pingTimeout: 60000,
  pingInterval: 25000
});
```

**2. Vite开发环境代理配置：**
```javascript
// vite.config.js - 完整代理配置
import { defineConfig, loadEnv } from 'vite';
import vue from '@vitejs/plugin-vue';

export default defineConfig(({ command, mode }) => {
  // 加载环境变量
  const env = loadEnv(mode, process.cwd(), '');
  
  return {
    plugins: [vue()],
    base: './', // 相对路径，适配Electron
    
    // 开发服务器配置
    server: {
      host: '0.0.0.0',
      port: 5173,
      open: true, // 自动打开浏览器
      
      // 详细的代理配置
      proxy: {
        // API代理
        '/api': {
          target: env.VITE_BASE_URL || 'http://localhost:3000',
          changeOrigin: true,
          secure: false,
          configure: (proxy, options) => {
            // 代理错误处理
            proxy.on('error', (err, req, res) => {
              console.error('代理错误:', err);
            });
            
            // 代理请求日志
            proxy.on('proxyReq', (proxyReq, req, res) => {
              console.log(`代理请求: ${req.method} ${req.url} -> ${proxyReq.path}`);
            });
          }
        },
        
        // Socket.IO代理
        '/socket.io': {
          target: env.VITE_BASE_URL || 'http://localhost:3000',
          changeOrigin: true,
          ws: true, // 启用WebSocket代理
          secure: false,
          timeout: 60000,
          configure: (proxy, options) => {
            proxy.on('upgrade', (req, socket, head) => {
              console.log('WebSocket升级请求:', req.url);
            });
          }
        },
        
        // 文件上传代理
        '/uploads': {
          target: env.VITE_BASE_URL || 'http://localhost:3000',
          changeOrigin: true,
          secure: false
        }
      },
      
      // CORS配置（开发环境）
      cors: {
        origin: true,
        credentials: true
      }
    },
    
    // 构建配置
    build: {
      outDir: 'dist-new',
      assetsDir: 'assets',
      sourcemap: mode === 'development',
      
      // 分包策略
      rollupOptions: {
        output: {
          manualChunks: {
            vendor: ['vue', 'vue-router', 'pinia'],
            socket: ['socket.io-client'],
            utils: ['axios', 'crypto-js']
          }
        }
      }
    },
    
    // 环境变量配置
    define: {
      __VUE_OPTIONS_API__: true,
      __VUE_PROD_DEVTOOLS__: false
    }
  };
});
```

### Q24.1: 生产环境如何优化CORS配置？
**A:** 生产环境需要更严格的安全配置：
```javascript
// 生产环境CORS配置
if (process.env.NODE_ENV === 'production') {
  const productionCors = {
    origin: [
      'https://yourdomain.com',
      'https://www.yourdomain.com',
      'https://app.yourdomain.com'
    ],
    credentials: true,
    methods: ['GET', 'POST', 'PUT', 'DELETE'],
    allowedHeaders: ['Content-Type', 'Authorization'],
    maxAge: 86400, // 24小时缓存
    
    // 安全头设置
    optionsSuccessStatus: 200
  };
  
  app.use(cors(productionCors));
  
  // 额外安全头
  app.use((req, res, next) => {
    res.header('X-Content-Type-Options', 'nosniff');
    res.header('X-Frame-Options', 'DENY');
    res.header('X-XSS-Protection', '1; mode=block');
    next();
  });
}
```

### Q24.2: 如何处理Electron应用的跨域问题？
**A:** Electron应用有特殊的跨域处理：
```javascript
// main.js - Electron主进程配置
const { app, BrowserWindow } = require('electron');

function createWindow() {
  const mainWindow = new BrowserWindow({
    width: 1200,
    height: 800,
    webPreferences: {
      nodeIntegration: false,
      contextIsolation: true,
      enableRemoteModule: false,
      
      // 允许跨域请求
      webSecurity: false, // 仅开发环境使用
      
      // 自定义协议处理
      additionalArguments: ['--disable-web-security']
    }
  });
  
  // 处理跨域请求
  mainWindow.webContents.session.webRequest.onBeforeSendHeaders(
    (details, callback) => {
      // 添加必要的请求头
      details.requestHeaders['User-Agent'] = 'CoffeeChatBar-Electron';
      callback({ requestHeaders: details.requestHeaders });
    }
  );
  
  // 处理响应头
  mainWindow.webContents.session.webRequest.onHeadersReceived(
    (details, callback) => {
      // 修改响应头以允许跨域
      if (details.responseHeaders) {
        details.responseHeaders['Access-Control-Allow-Origin'] = ['*'];
        details.responseHeaders['Access-Control-Allow-Methods'] = ['GET', 'POST', 'PUT', 'DELETE'];
      }
      callback({ responseHeaders: details.responseHeaders });
    }
  );
}
```

### Q25: 错误处理机制是怎样的？
**A:** 多层错误处理：
1. **后端统一错误处理**:
```javascript
try {
  // 业务逻辑
} catch (err) {
  console.error('操作失败', err);
  res.status(500).json({ message: "服务器内部错误" });
}
```
2. **前端错误捕获**:
```javascript
try {
  const response = await axios.post('/api/endpoint')
} catch (error) {
  if (error.response?.status === 401) {
    // 处理认证失败
    router.push('/login')
  }
}
```

---

## 安全性问答

### Q26: 项目中实现了哪些安全措施？
**A:** 多重安全措施：
1. **密码加密**: bcrypt加盐哈希
2. **JWT认证**: 无状态身份验证
3. **输入验证**: 前后端双重验证
4. **CORS配置**: 跨域访问控制
5. **文件上传安全**: 文件类型和大小限制

### Q27: 如何防止XSS攻击？
**A:** 
1. **输入转义**: Vue.js自动转义模板中的内容
2. **内容安全策略**: 避免直接插入HTML
3. **文件上传验证**: 严格验证上传文件类型
```javascript
// 安全的内容渲染
<template>
  <div>{{ userInput }}</div> <!-- Vue自动转义 -->
</template>
```

### Q28: JWT Token的安全性如何保证？
**A:** 实现多层JWT安全策略：

**1. Token生成与配置：**
```javascript
// server/utils/jwtUtils.js - JWT安全工具
const jwt = require('jsonwebtoken');
const crypto = require('crypto');

class JWTSecurity {
  constructor() {
    this.accessTokenExpiry = '15m';     // 访问token短期有效
    this.refreshTokenExpiry = '7d';     // 刷新token长期有效
    this.issuer = 'coffee-chat-bar';    // 签发者
    this.audience = 'ccb-users';        // 受众
  }
  
  // 生成访问token
  generateAccessToken(payload) {
    const tokenPayload = {
      ...payload,
      type: 'access',
      iat: Math.floor(Date.now() / 1000),
      jti: crypto.randomUUID(), // JWT ID，用于撤销
      deviceFingerprint: this.generateDeviceFingerprint(payload.userAgent, payload.ip)
    };
    
    return jwt.sign(tokenPayload, process.env.JWT_ACCESS_SECRET, {
      expiresIn: this.accessTokenExpiry,
      issuer: this.issuer,
      audience: this.audience,
      algorithm: 'HS256'
    });
  }
  
  // 生成刷新token
  generateRefreshToken(payload) {
    const tokenPayload = {
      userId: payload.userId,
      type: 'refresh',
      iat: Math.floor(Date.now() / 1000),
      jti: crypto.randomUUID(),
      tokenFamily: crypto.randomUUID() // token家族ID，用于检测token重用
    };
    
    return jwt.sign(tokenPayload, process.env.JWT_REFRESH_SECRET, {
      expiresIn: this.refreshTokenExpiry,
      issuer: this.issuer,
      audience: this.audience,
      algorithm: 'HS256'
    });
  }
  
  // 生成设备指纹
  generateDeviceFingerprint(userAgent, ip) {
    const fingerprint = crypto
      .createHash('sha256')
      .update(`${userAgent}${ip}${process.env.DEVICE_SECRET}`)
      .digest('hex');
    return fingerprint.substring(0, 16); // 截取前16位
  }
  
  // 验证访问token
  verifyAccessToken(token) {
    try {
      const decoded = jwt.verify(token, process.env.JWT_ACCESS_SECRET, {
        issuer: this.issuer,
        audience: this.audience,
        algorithms: ['HS256']
      });
      
      // 检查token类型
      if (decoded.type !== 'access') {
        throw new Error('Invalid token type');
      }
      
      return { valid: true, decoded };
    } catch (error) {
      return { valid: false, error: error.message };
    }
  }
  
  // 验证刷新token
  verifyRefreshToken(token) {
    try {
      const decoded = jwt.verify(token, process.env.JWT_REFRESH_SECRET, {
        issuer: this.issuer,
        audience: this.audience,
        algorithms: ['HS256']
      });
      
      if (decoded.type !== 'refresh') {
        throw new Error('Invalid token type');
      }
      
      return { valid: true, decoded };
    } catch (error) {
      return { valid: false, error: error.message };
    }
  }
  
  // Token轮换（刷新）
  async rotateTokens(refreshToken, userInfo) {
    const verification = this.verifyRefreshToken(refreshToken);
    
    if (!verification.valid) {
      throw new Error('Invalid refresh token');
    }
    
    const { decoded } = verification;
    
    // 检查token家族是否被重用（安全检测）
    const isTokenReused = await this.checkTokenReuse(decoded.tokenFamily, decoded.jti);
    if (isTokenReused) {
      // 检测到token重用，撤销整个token家族
      await this.revokeTokenFamily(decoded.tokenFamily);
      throw new Error('Token reuse detected, all tokens revoked');
    }
    
    // 生成新的token对
    const newAccessToken = this.generateAccessToken({
      userId: decoded.userId,
      username: userInfo.username,
      userAgent: userInfo.userAgent,
      ip: userInfo.ip
    });
    
    const newRefreshToken = this.generateRefreshToken({
      userId: decoded.userId
    });
    
    // 将旧的refresh token加入黑名单
    await this.blacklistToken(refreshToken);
    
    // 记录新的token家族
    await this.recordTokenFamily(decoded.tokenFamily, newRefreshToken);
    
    return {
      accessToken: newAccessToken,
      refreshToken: newRefreshToken,
      expiresIn: 15 * 60 // 15分钟
    };
  }
  
  // 检查token重用
  async checkTokenReuse(tokenFamily, jti) {
    try {
      const redis = require('../config/redis');
      const usedTokens = await redis.smembers(`token_family:${tokenFamily}`);
      return usedTokens.includes(jti);
    } catch (error) {
      console.error('检查token重用失败:', error);
      return false;
    }
  }
  
  // 撤销token家族
  async revokeTokenFamily(tokenFamily) {
    try {
      const redis = require('../config/redis');
      await redis.del(`token_family:${tokenFamily}`);
      
      // 记录安全事件
      const SecurityEvent = require('../models/SecurityEvent');
      await SecurityEvent.create({
        eventType: 'TOKEN_FAMILY_REVOKED',
        tokenFamily,
        timestamp: new Date(),
        reason: 'Token reuse detected'
      });
    } catch (error) {
      console.error('撤销token家族失败:', error);
    }
  }
  
  // 将token加入黑名单
  async blacklistToken(token) {
    try {
      const redis = require('../config/redis');
      const decoded = jwt.decode(token);
      
      if (decoded && decoded.exp) {
        const ttl = decoded.exp - Math.floor(Date.now() / 1000);
        if (ttl > 0) {
          const tokenHash = crypto.createHash('sha256').update(token).digest('hex');
          await redis.setex(`blacklist:${tokenHash}`, ttl, '1');
        }
      }
    } catch (error) {
      console.error('加入黑名单失败:', error);
    }
  }
  
  // 记录token家族
  async recordTokenFamily(tokenFamily, refreshToken) {
    try {
      const redis = require('../config/redis');
      const decoded = jwt.decode(refreshToken);
      
      if (decoded && decoded.jti) {
        await redis.sadd(`token_family:${tokenFamily}`, decoded.jti);
        await redis.expire(`token_family:${tokenFamily}`, 7 * 24 * 60 * 60); // 7天过期
      }
    } catch (error) {
      console.error('记录token家族失败:', error);
    }
  }
}

// 导出单例
module.exports = new JWTSecurity();
```

**2. 前端Token安全存储：**
```javascript
// utils/tokenStorage.js - 安全的Token存储
class SecureTokenStorage {
  constructor() {
    this.accessTokenKey = 'ccb_access_token';
    this.refreshTokenKey = 'ccb_refresh_token';
    this.encryptionKey = this.getOrCreateEncryptionKey();
  }
  
  // 获取或创建加密密钥
  getOrCreateEncryptionKey() {
    let key = localStorage.getItem('ccb_encryption_key');
    if (!key) {
      // 生成基于设备的加密密钥
      const deviceInfo = {
        userAgent: navigator.userAgent,
        language: navigator.language,
        platform: navigator.platform,
        screenResolution: `${screen.width}x${screen.height}`,
        timezone: Intl.DateTimeFormat().resolvedOptions().timeZone
      };
      
      key = this.generateKeyFromDevice(deviceInfo);
      localStorage.setItem('ccb_encryption_key', key);
    }
    return key;
  }
  
  // 基于设备信息生成密钥
  generateKeyFromDevice(deviceInfo) {
    const deviceString = JSON.stringify(deviceInfo);
    // 使用Web Crypto API生成密钥（简化版本）
    let hash = 0;
    for (let i = 0; i < deviceString.length; i++) {
      const char = deviceString.charCodeAt(i);
      hash = ((hash << 5) - hash) + char;
      hash = hash & hash; // 转换为32位整数
    }
    return Math.abs(hash).toString(36);
  }
  
  // 简单的XOR加密（生产环境建议使用Web Crypto API）
  encrypt(text, key) {
    let result = '';
    for (let i = 0; i < text.length; i++) {
      result += String.fromCharCode(
        text.charCodeAt(i) ^ key.charCodeAt(i % key.length)
      );
    }
    return btoa(result); // Base64编码
  }
  
  // XOR解密
  decrypt(encryptedText, key) {
    try {
      const text = atob(encryptedText); // Base64解码
      let result = '';
      for (let i = 0; i < text.length; i++) {
        result += String.fromCharCode(
          text.charCodeAt(i) ^ key.charCodeAt(i % key.length)
        );
      }
      return result;
    } catch (error) {
      console.error('Token解密失败:', error);
      return null;
    }
  }
  
  // 存储访问token
  setAccessToken(token) {
    try {
      const encryptedToken = this.encrypt(token, this.encryptionKey);
      sessionStorage.setItem(this.accessTokenKey, encryptedToken);
      
      // 设置自动清理
      setTimeout(() => {
        this.removeAccessToken();
      }, 15 * 60 * 1000); // 15分钟后自动清理
    } catch (error) {
      console.error('存储访问token失败:', error);
    }
  }
  
  // 获取访问token
  getAccessToken() {
    try {
      const encryptedToken = sessionStorage.getItem(this.accessTokenKey);
      if (!encryptedToken) return null;
      
      return this.decrypt(encryptedToken, this.encryptionKey);
    } catch (error) {
      console.error('获取访问token失败:', error);
      return null;
    }
  }
  
  // 存储刷新token
  setRefreshToken(token) {
    try {
      const encryptedToken = this.encrypt(token, this.encryptionKey);
      localStorage.setItem(this.refreshTokenKey, encryptedToken);
    } catch (error) {
      console.error('存储刷新token失败:', error);
    }
  }
  
  // 获取刷新token
  getRefreshToken() {
    try {
      const encryptedToken = localStorage.getItem(this.refreshTokenKey);
      if (!encryptedToken) return null;
      
      return this.decrypt(encryptedToken, this.encryptionKey);
    } catch (error) {
      console.error('获取刷新token失败:', error);
      return null;
    }
  }
  
  // 清理所有token
  clearTokens() {
    sessionStorage.removeItem(this.accessTokenKey);
    localStorage.removeItem(this.refreshTokenKey);
  }
  
  // 移除访问token
  removeAccessToken() {
    sessionStorage.removeItem(this.accessTokenKey);
  }
  
  // 检查token是否即将过期
  isTokenExpiringSoon(token, thresholdMinutes = 5) {
    try {
      const payload = JSON.parse(atob(token.split('.')[1]));
      const expirationTime = payload.exp * 1000;
      const currentTime = Date.now();
      const timeUntilExpiry = expirationTime - currentTime;
      
      return timeUntilExpiry < (thresholdMinutes * 60 * 1000);
    } catch (error) {
      console.error('检查token过期时间失败:', error);
      return true; // 如果无法解析，认为已过期
    }
  }
}

// 导出单例
export const tokenStorage = new SecureTokenStorage();
export default tokenStorage;
```

### Q28.1: 如何实现Token自动刷新机制？
**A:** 实现无感知的Token刷新：

```javascript
// utils/authInterceptor.js - 认证拦截器
import axios from 'axios';
import { tokenStorage } from './tokenStorage';
import { useRouter } from 'vue-router';

class AuthInterceptor {
  constructor() {
    this.isRefreshing = false;
    this.failedQueue = [];
    this.setupInterceptors();
  }
  
  // 设置请求和响应拦截器
  setupInterceptors() {
    // 请求拦截器 - 自动添加token
    axios.interceptors.request.use(
      async (config) => {
        let accessToken = tokenStorage.getAccessToken();
        
        // 检查token是否即将过期
        if (accessToken && tokenStorage.isTokenExpiringSoon(accessToken)) {
          try {
            accessToken = await this.refreshTokenIfNeeded();
          } catch (error) {
            console.error('Token刷新失败:', error);
            this.handleAuthFailure();
            return Promise.reject(error);
          }
        }
        
        if (accessToken) {
          config.headers.Authorization = `Bearer ${accessToken}`;
        }
        
        return config;
      },
      (error) => Promise.reject(error)
    );
    
    // 响应拦截器 - 处理401错误
    axios.interceptors.response.use(
      (response) => response,
      async (error) => {
        const originalRequest = error.config;
        
        if (error.response?.status === 401 && !originalRequest._retry) {
          if (this.isRefreshing) {
            // 如果正在刷新token，将请求加入队列
            return new Promise((resolve, reject) => {
              this.failedQueue.push({ resolve, reject });
            }).then(token => {
              originalRequest.headers.Authorization = `Bearer ${token}`;
              return axios(originalRequest);
            }).catch(err => {
              return Promise.reject(err);
            });
          }
          
          originalRequest._retry = true;
          this.isRefreshing = true;
          
          try {
            const newAccessToken = await this.refreshToken();
            
            // 处理队列中的请求
            this.processQueue(null, newAccessToken);
            
            // 重试原始请求
            originalRequest.headers.Authorization = `Bearer ${newAccessToken}`;
            return axios(originalRequest);
            
          } catch (refreshError) {
            // 刷新失败，处理队列中的请求
            this.processQueue(refreshError, null);
            this.handleAuthFailure();
            return Promise.reject(refreshError);
          } finally {
            this.isRefreshing = false;
          }
        }
        
        return Promise.reject(error);
      }
    );
  }
  
  // 刷新token
  async refreshToken() {
    const refreshToken = tokenStorage.getRefreshToken();
    
    if (!refreshToken) {
      throw new Error('No refresh token available');
    }
    
    try {
      const response = await axios.post('/auth/refresh', {
        refreshToken
      }, {
        // 不使用拦截器，避免循环
        skipAuthRefresh: true
      });
      
      const { accessToken, refreshToken: newRefreshToken } = response.data;
      
      // 存储新的token
      tokenStorage.setAccessToken(accessToken);
      if (newRefreshToken) {
        tokenStorage.setRefreshToken(newRefreshToken);
      }
      
      return accessToken;
      
    } catch (error) {
      console.error('Token刷新失败:', error);
      throw error;
    }
  }
  
  // 检查并刷新token
  async refreshTokenIfNeeded() {
    const accessToken = tokenStorage.getAccessToken();
    
    if (!accessToken || tokenStorage.isTokenExpiringSoon(accessToken)) {
      return await this.refreshToken();
    }
    
    return accessToken;
  }
  
  // 处理队列中的请求
  processQueue(error, token = null) {
    this.failedQueue.forEach(({ resolve, reject }) => {
      if (error) {
        reject(error);
      } else {
        resolve(token);
      }
    });
    
    this.failedQueue = [];
  }
  
  // 处理认证失败
  handleAuthFailure() {
    tokenStorage.clearTokens();
    
    // 跳转到登录页
    const router = useRouter();
    router.push('/login');
    
    // 显示提示信息
    ElMessage.warning('登录已过期，请重新登录');
  }
}

// 创建并导出拦截器实例
export const authInterceptor = new AuthInterceptor();
export default authInterceptor;
```

### Q28.2: 如何防范JWT相关的安全攻击？
**A:** 实现全面的JWT安全防护：

```javascript
// middlewares/jwtSecurity.js - JWT安全中间件
const rateLimit = require('express-rate-limit');
const slowDown = require('express-slow-down');

// JWT相关的限流配置
const jwtLimiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15分钟
  max: 100, // 每个IP最多100次JWT相关请求
  message: {
    error: 'JWT请求过于频繁',
    code: 'JWT_RATE_LIMIT_EXCEEDED'
  },
  standardHeaders: true,
  legacyHeaders: false
});

// 刷新token限流（更严格）
const refreshTokenLimiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15分钟
  max: 10, // 每个IP最多10次刷新请求
  message: {
    error: 'Token刷新过于频繁',
    code: 'REFRESH_RATE_LIMIT_EXCEEDED'
  },
  keyGenerator: (req) => {
    // 基于IP和用户ID限流
    const ip = req.ip;
    const userId = req.body.userId || 'anonymous';
    return `${ip}:${userId}`;
  }
});

// 慢速响应（防止暴力破解）
const jwtSlowDown = slowDown({
  windowMs: 15 * 60 * 1000, // 15分钟
  delayAfter: 50, // 50次请求后开始延迟
  delayMs: 500, // 每次增加500ms延迟
  maxDelayMs: 20000 // 最大延迟20秒
});

// JWT安全验证中间件
const jwtSecurityCheck = async (req, res, next) => {
  try {
    const token = req.headers.authorization?.split(' ')[1];
    
    if (!token) {
      return next();
    }
    
    // 1. 检查token格式
    const tokenParts = token.split('.');
    if (tokenParts.length !== 3) {
      return res.status(401).json({
        error: 'Invalid token format',
        code: 'INVALID_TOKEN_FORMAT'
      });
    }
    
    // 2. 检查token长度（防止过长的恶意token）
    if (token.length > 2048) {
      return res.status(401).json({
        error: 'Token too long',
        code: 'TOKEN_TOO_LONG'
      });
    }
    
    // 3. 检查payload大小
    try {
      const payload = JSON.parse(atob(tokenParts[1]));
      const payloadSize = JSON.stringify(payload).length;
      
      if (payloadSize > 1024) { // 1KB限制
        return res.status(401).json({
          error: 'Token payload too large',
          code: 'PAYLOAD_TOO_LARGE'
        });
      }
      
      // 4. 检查必要的声明
      const requiredClaims = ['iat', 'exp', 'iss', 'aud'];
      for (const claim of requiredClaims) {
        if (!payload[claim]) {
          return res.status(401).json({
            error: `Missing required claim: ${claim}`,
            code: 'MISSING_CLAIM'
          });
        }
      }
      
      // 5. 检查时间声明的合理性
      const now = Math.floor(Date.now() / 1000);
      
      // 检查签发时间不能是未来
      if (payload.iat > now + 60) { // 允许1分钟时钟偏差
        return res.status(401).json({
          error: 'Token issued in the future',
          code: 'FUTURE_TOKEN'
        });
      }
      
      // 检查过期时间
      if (payload.exp <= now) {
        return res.status(401).json({
          error: 'Token expired',
          code: 'TOKEN_EXPIRED'
        });
      }
      
      // 6. 检查token生命周期是否合理
      const tokenLifetime = payload.exp - payload.iat;
      const maxLifetime = payload.type === 'access' ? 3600 : 7 * 24 * 3600; // 1小时或7天
      
      if (tokenLifetime > maxLifetime) {
        return res.status(401).json({
          error: 'Token lifetime too long',
          code: 'EXCESSIVE_LIFETIME'
        });
      }
      
      // 7. 检查签发者和受众
      if (payload.iss !== 'coffee-chat-bar' || payload.aud !== 'ccb-users') {
        return res.status(401).json({
          error: 'Invalid token issuer or audience',
          code: 'INVALID_ISSUER_AUDIENCE'
        });
      }
      
    } catch (decodeError) {
      return res.status(401).json({
        error: 'Invalid token payload',
        code: 'INVALID_PAYLOAD'
      });
    }
    
    next();
    
  } catch (error) {
    console.error('JWT安全检查失败:', error);
    res.status(500).json({
      error: 'Security check failed',
      code: 'SECURITY_CHECK_FAILED'
    });
  }
};

// 检测JWT攻击模式
const detectJWTAttacks = async (req, res, next) => {
  try {
    const token = req.headers.authorization?.split(' ')[1];
    const ip = req.ip;
    const userAgent = req.headers['user-agent'];
    
    if (!token) {
      return next();
    }
    
    // 检测常见的JWT攻击模式
    const attackPatterns = [
      // None算法攻击
      /"alg"\s*:\s*"none"/i,
      // 空密钥攻击
      /"alg"\s*:\s*"HS256".*"key"\s*:\s*""/i,
      // 算法混淆攻击
      /"alg"\s*:\s*"RS256".*"HS256"/i,
      // 过长的声明
      /".{10000,}/
    ];
    
    for (const pattern of attackPatterns) {
      if (pattern.test(token)) {
        // 记录攻击尝试
        await logSecurityIncident({
          type: 'JWT_ATTACK_DETECTED',
          ip,
          userAgent,
          token: token.substring(0, 100) + '...', // 只记录前100个字符
          pattern: pattern.toString(),
          timestamp: new Date()
        });
        
        return res.status(401).json({
          error: 'Malicious token detected',
          code: 'MALICIOUS_TOKEN'
        });
      }
    }
    
    next();
    
  } catch (error) {
    console.error('JWT攻击检测失败:', error);
    next(); // 检测失败不应阻止正常请求
  }
};

// 记录安全事件
async function logSecurityIncident(incident) {
  try {
    const SecurityIncident = require('../models/SecurityIncident');
    await SecurityIncident.create(incident);
    
    // 如果是严重攻击，发送警报
    if (incident.type === 'JWT_ATTACK_DETECTED') {
      await sendSecurityAlert(incident);
    }
  } catch (error) {
    console.error('记录安全事件失败:', error);
  }
}

// 发送安全警报
async function sendSecurityAlert(incident) {
  // 这里可以集成邮件、短信或其他警报系统
  console.warn('🚨 安全警报:', incident);
  
  // 示例：发送到监控系统
  if (process.env.SECURITY_WEBHOOK_URL) {
    try {
      await axios.post(process.env.SECURITY_WEBHOOK_URL, {
        text: `JWT攻击检测: ${incident.type} from ${incident.ip}`,
        incident
      });
    } catch (error) {
      console.error('发送安全警报失败:', error);
    }
  }
}

module.exports = {
  jwtLimiter,
  refreshTokenLimiter,
  jwtSlowDown,
  jwtSecurityCheck,
  detectJWTAttacks
};
```

---

## 性能优化问答

### Q29: 前端有哪些性能优化措施？
**A:** 实现全方位的前端性能优化策略：

**1. Vite构建优化配置：**
```javascript
// vite.config.js - 性能优化配置
import { defineConfig } from 'vite';
import vue from '@vitejs/plugin-vue';
import { resolve } from 'path';
import { visualizer } from 'rollup-plugin-visualizer';
import { compression } from 'vite-plugin-compression';

export default defineConfig({
  plugins: [
    vue(),
    
    // Gzip压缩
    compression({
      algorithm: 'gzip',
      ext: '.gz',
      threshold: 1024, // 只压缩大于1KB的文件
      deleteOriginFile: false
    }),
    
    // Brotli压缩（更高压缩率）
    compression({
      algorithm: 'brotliCompress',
      ext: '.br',
      threshold: 1024
    }),
    
    // 打包分析工具
    visualizer({
      filename: 'dist/stats.html',
      open: true,
      gzipSize: true,
      brotliSize: true
    })
  ],
  
  // 构建优化
  build: {
    target: 'es2015', // 支持现代浏览器
    minify: 'terser', // 使用terser进行代码压缩
    
    terserOptions: {
      compress: {
        drop_console: true, // 生产环境移除console
        drop_debugger: true, // 移除debugger
        pure_funcs: ['console.log'], // 移除特定函数调用
        reduce_vars: true, // 减少变量
        sequences: true, // 合并连续语句
        conditionals: true, // 优化条件语句
        comparisons: true, // 优化比较操作
        evaluate: true, // 计算常量表达式
        booleans: true, // 优化布尔值
        loops: true, // 优化循环
        unused: true, // 移除未使用代码
        hoist_funs: true, // 提升函数声明
        if_return: true, // 优化if-return语句
        join_vars: true, // 合并变量声明
        cascade: true, // 优化连续赋值
        side_effects: false // 移除无副作用的代码
      },
      mangle: {
        safari10: true // 兼容Safari 10
      }
    },
    
    // 代码分割配置
    rollupOptions: {
      output: {
        // 手动分包策略
        manualChunks: {
          // Vue核心库
          'vue-vendor': ['vue', 'vue-router', 'pinia'],
          
          // UI组件库
          'ui-vendor': ['element-plus'],
          
          // 工具库
          'utils-vendor': ['axios', 'dayjs', 'lodash-es'],
          
          // Socket.IO相关
          'socket-vendor': ['socket.io-client']
        },
        
        // 文件命名策略
        chunkFileNames: (chunkInfo) => {
          const facadeModuleId = chunkInfo.facadeModuleId
            ? chunkInfo.facadeModuleId.split('/').pop().replace(/\.[^.]*$/, '')
            : 'chunk';
          return `js/${facadeModuleId}-[hash].js`;
        },
        
        entryFileNames: 'js/[name]-[hash].js',
        assetFileNames: (assetInfo) => {
          const info = assetInfo.name.split('.');
          let extType = info[info.length - 1];
          
          // 根据文件类型分目录
          if (/\.(mp4|webm|ogg|mp3|wav|flac|aac)$/i.test(assetInfo.name)) {
            extType = 'media';
          } else if (/\.(png|jpe?g|gif|svg|webp|avif)$/i.test(assetInfo.name)) {
            extType = 'images';
          } else if (/\.(woff2?|eot|ttf|otf)$/i.test(assetInfo.name)) {
            extType = 'fonts';
          }
          
          return `${extType}/[name]-[hash].[ext]`;
        }
      }
    },
    
    // 启用CSS代码分割
    cssCodeSplit: true,
    
    // 设置chunk大小警告限制
    chunkSizeWarningLimit: 1000, // 1MB
    
    // 启用CSS压缩
    cssMinify: true
  },
  
  // 开发服务器优化
  server: {
    hmr: {
      overlay: false // 禁用错误覆盖层，提升开发体验
    },
    
    // 预构建优化
    optimizeDeps: {
      include: [
        'vue',
        'vue-router',
        'pinia',
        'element-plus',
        'axios',
        'socket.io-client',
        'dayjs'
      ]
    }
  }
});
```

**2. 组件懒加载和代码分割：**
```javascript
// router/index.js - 路由懒加载
import { createRouter, createWebHistory } from 'vue-router';

// 路由懒加载函数
const lazyLoad = (view) => {
  return () => import(`@/views/${view}.vue`);
};

// 带加载状态的懒加载
const lazyLoadWithLoading = (view) => {
  return () => ({
    component: import(`@/views/${view}.vue`),
    loading: () => import('@/components/Loading.vue'), // 加载中组件
    error: () => import('@/components/Error.vue'), // 错误组件
    delay: 200, // 延迟显示加载组件的时间
    timeout: 10000 // 超时时间
  });
};

// 预加载关键路由
const preloadRoutes = [
  'Chat', 'Friends', 'Settings'
];

// 预加载函数
const preloadComponents = () => {
  preloadRoutes.forEach(route => {
    import(`@/views/${route}.vue`).catch(err => {
      console.warn(`预加载组件 ${route} 失败:`, err);
    });
  });
};

const routes = [
  {
    path: '/',
    name: 'Home',
    component: lazyLoad('Home'),
    meta: {
      title: '首页',
      keepAlive: true, // 缓存组件
      preload: true // 标记为预加载
    }
  },
  {
    path: '/chat',
    name: 'Chat',
    component: lazyLoadWithLoading('Chat'),
    meta: {
      title: '聊天',
      requiresAuth: true,
      keepAlive: true
    }
  }
];

const router = createRouter({
  history: createWebHistory(),
  routes,
  
  // 滚动行为优化
  scrollBehavior(to, from, savedPosition) {
    if (savedPosition) {
      return savedPosition;
    } else {
      return { top: 0, behavior: 'smooth' };
    }
  }
});

// 路由守卫 - 预加载优化
router.beforeEach(async (to, from, next) => {
  // 预加载下一个可能访问的路由
  if (to.meta.preload) {
    setTimeout(preloadComponents, 1000);
  }
  
  next();
});

export default router;
```

**3. 图片和资源优化：**
```javascript
// utils/imageOptimizer.js - 图片优化工具
class ImageOptimizer {
  constructor() {
    this.cache = new Map();
    this.observer = null;
    this.setupLazyLoading();
  }
  
  // 设置图片懒加载
  setupLazyLoading() {
    if ('IntersectionObserver' in window) {
      this.observer = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
          if (entry.isIntersecting) {
            const img = entry.target;
            this.loadImage(img);
            this.observer.unobserve(img);
          }
        });
      }, {
        rootMargin: '50px 0px', // 提前50px开始加载
        threshold: 0.01
      });
    }
  }
  
  // 加载图片
  async loadImage(img) {
    const src = img.dataset.src;
    if (!src) return;
    
    try {
      // 检查缓存
      if (this.cache.has(src)) {
        img.src = this.cache.get(src);
        img.classList.add('loaded');
        return;
      }
      
      // 创建新的图片对象进行预加载
      const imageLoader = new Image();
      
      imageLoader.onload = () => {
        // 图片加载成功
        img.src = src;
        img.classList.add('loaded');
        this.cache.set(src, src);
        
        // 限制缓存大小
        if (this.cache.size > 100) {
          const firstKey = this.cache.keys().next().value;
          this.cache.delete(firstKey);
        }
      };
      
      imageLoader.onerror = () => {
        // 图片加载失败，使用默认图片
        img.src = '/images/default-avatar.svg';
        img.classList.add('error');
      };
      
      imageLoader.src = src;
      
    } catch (error) {
      console.error('图片加载失败:', error);
      img.src = '/images/default-avatar.svg';
      img.classList.add('error');
    }
  }
  
  // 观察图片元素
  observe(img) {
    if (this.observer && img) {
      this.observer.observe(img);
    }
  }
  
  // 停止观察
  unobserve(img) {
    if (this.observer && img) {
      this.observer.unobserve(img);
    }
  }
  
  // 预加载关键图片
  preloadCriticalImages(urls) {
    urls.forEach(url => {
      if (!this.cache.has(url)) {
        const img = new Image();
        img.onload = () => {
          this.cache.set(url, url);
        };
        img.src = url;
      }
    });
  }
  
  // 清理缓存
  clearCache() {
    this.cache.clear();
  }
  
  // 销毁观察器
  destroy() {
    if (this.observer) {
      this.observer.disconnect();
      this.observer = null;
    }
    this.clearCache();
  }
}

// 导出单例
export const imageOptimizer = new ImageOptimizer();
export default imageOptimizer;
```

### Q29.1: 如何实现虚拟滚动优化长列表性能？
**A:** 实现高性能的虚拟滚动组件：

```vue
<!-- components/VirtualList.vue - 虚拟滚动组件 -->
<template>
  <div class="virtual-list-container" ref="containerRef">
    <div 
      class="virtual-scroll-container"
      :style="{ height: containerHeight + 'px' }"
      @scroll="handleScroll"
      ref="scrollRef"
    >
      <!-- 占位元素（上方） -->
      <div :style="{ height: offsetY + 'px' }"></div>
      
      <!-- 可见的列表项 -->
      <div 
        v-for="(item, index) in visibleItems"
        :key="getItemKey(item, startIndex + index)"
        class="virtual-list-item"
        :style="{ height: itemHeight + 'px' }"
      >
        <slot :item="item" :index="startIndex + index"></slot>
      </div>
      
      <!-- 占位元素（下方） -->
      <div :style="{ height: (totalHeight - offsetY - visibleHeight) + 'px' }"></div>
    </div>
  </div>
</template>

<script setup>
import { ref, computed, onMounted, onUnmounted, watch } from 'vue';
import { throttle } from 'lodash-es';

// Props
const props = defineProps({
  items: {
    type: Array,
    default: () => []
  },
  itemHeight: {
    type: Number,
    default: 50
  },
  containerHeight: {
    type: Number,
    default: 400
  },
  overscan: {
    type: Number,
    default: 5 // 额外渲染的项目数量
  },
  keyField: {
    type: String,
    default: 'id'
  }
});

// Refs
const containerRef = ref(null);
const scrollRef = ref(null);
const scrollTop = ref(0);

// Computed
const visibleCount = computed(() => {
  return Math.ceil(props.containerHeight / props.itemHeight) + props.overscan * 2;
});

const startIndex = computed(() => {
  const index = Math.floor(scrollTop.value / props.itemHeight) - props.overscan;
  return Math.max(0, index);
});

const endIndex = computed(() => {
  return Math.min(startIndex.value + visibleCount.value, props.items.length);
});

const visibleItems = computed(() => {
  return props.items.slice(startIndex.value, endIndex.value);
});

const offsetY = computed(() => {
  return startIndex.value * props.itemHeight;
});

const totalHeight = computed(() => {
  return props.items.length * props.itemHeight;
});

const visibleHeight = computed(() => {
  return visibleCount.value * props.itemHeight;
});

// 获取项目的唯一键
const getItemKey = (item, index) => {
  return item[props.keyField] || index;
};

// 滚动处理（节流）
const handleScroll = throttle((event) => {
  scrollTop.value = event.target.scrollTop;
}, 16); // 60fps

// 滚动到指定索引
const scrollToIndex = (index) => {
  if (scrollRef.value) {
    const targetScrollTop = index * props.itemHeight;
    scrollRef.value.scrollTop = targetScrollTop;
  }
};

// 滚动到顶部
const scrollToTop = () => {
  scrollToIndex(0);
};

// 滚动到底部
const scrollToBottom = () => {
  scrollToIndex(props.items.length - 1);
};

// 暴露方法
defineExpose({
  scrollToIndex,
  scrollToTop,
  scrollToBottom
});

// 监听数据变化
watch(() => props.items.length, (newLength, oldLength) => {
  // 如果数据增加且用户在底部，自动滚动到底部
  if (newLength > oldLength) {
    const { scrollTop: st, scrollHeight, clientHeight } = scrollRef.value;
    const isAtBottom = st + clientHeight >= scrollHeight - 10;
    
    if (isAtBottom) {
      setTimeout(() => {
        scrollToBottom();
      }, 0);
    }
  }
});
</script>

<style scoped>
.virtual-list-container {
  position: relative;
  height: 100%;
  overflow: hidden;
}

.virtual-scroll-container {
  height: 100%;
  overflow-y: auto;
  scroll-behavior: smooth;
}

.virtual-list-item {
  display: flex;
  align-items: center;
  border-bottom: 1px solid #f0f0f0;
}
</style>
```

### Q30: 后端性能优化策略？
**A:** 实现全面的后端性能优化：

**1. 数据库优化策略：**
```javascript
// config/database.js - 数据库连接优化
const mongoose = require('mongoose');

class DatabaseOptimizer {
  constructor() {
    this.connectionOptions = {
      // 连接池配置
      maxPoolSize: 10, // 最大连接数
      minPoolSize: 2,  // 最小连接数
      maxIdleTimeMS: 30000, // 连接最大空闲时间
      serverSelectionTimeoutMS: 5000, // 服务器选择超时
      socketTimeoutMS: 45000, // Socket超时
      
      // 缓冲配置
      bufferMaxEntries: 0, // 禁用mongoose缓冲
      bufferCommands: false,
      
      // 其他优化
      useNewUrlParser: true,
      useUnifiedTopology: true,
      
      // 读写分离（如果有副本集）
      readPreference: 'secondaryPreferred',
      
      // 压缩
      compressors: ['zlib'],
      zlibCompressionLevel: 6
    };
  }
  
  // 连接数据库
  async connect() {
    try {
      await mongoose.connect(process.env.MONGODB_URI, this.connectionOptions);
      
      // 监听连接事件
      mongoose.connection.on('connected', () => {
        console.log('✅ MongoDB连接成功');
      });
      
      mongoose.connection.on('error', (err) => {
        console.error('❌ MongoDB连接错误:', err);
      });
      
      mongoose.connection.on('disconnected', () => {
        console.log('⚠️ MongoDB连接断开');
      });
      
      // 优雅关闭
      process.on('SIGINT', async () => {
        await mongoose.connection.close();
        console.log('📴 MongoDB连接已关闭');
        process.exit(0);
      });
      
    } catch (error) {
      console.error('数据库连接失败:', error);
      process.exit(1);
    }
  }
  
  // 创建索引
  async createIndexes() {
    try {
      const User = require('../models/User');
      const Message = require('../models/Message');
      
      // 用户模型索引
      await User.collection.createIndex({ username: 1 }, { unique: true });
      await User.collection.createIndex({ email: 1 }, { unique: true });
      await User.collection.createIndex({ createdAt: -1 });
      await User.collection.createIndex({ lastActive: -1 });
      
      // 消息模型索引
      await Message.collection.createIndex({ senderId: 1, receiverId: 1 });
      await Message.collection.createIndex({ timestamp: -1 });
      await Message.collection.createIndex({ 
        senderId: 1, 
        receiverId: 1, 
        timestamp: -1 
      }); // 复合索引
      
      // 文本搜索索引
      await Message.collection.createIndex({ 
        content: 'text' 
      }, {
        weights: { content: 10 },
        name: 'message_text_index'
      });
      
      // TTL索引（自动删除过期数据）
      await Message.collection.createIndex(
        { timestamp: 1 },
        { 
          expireAfterSeconds: 365 * 24 * 60 * 60, // 1年后自动删除
          name: 'message_ttl_index'
        }
      );
      
      console.log('✅ 数据库索引创建完成');
      
    } catch (error) {
      console.error('创建索引失败:', error);
    }
  }
  
  // 数据库性能监控
  setupMonitoring() {
    // 慢查询监控
    mongoose.set('debug', (collectionName, method, query, doc) => {
      const start = Date.now();
      
      // 记录慢查询（超过100ms）
      setTimeout(() => {
        const duration = Date.now() - start;
        if (duration > 100) {
          console.warn(`🐌 慢查询检测: ${collectionName}.${method}`, {
            query,
            duration: `${duration}ms`
          });
        }
      }, 0);
    });
    
    // 连接池监控
    setInterval(() => {
      const stats = mongoose.connection.db.serverConfig.s.pool;
      if (stats) {
        console.log('📊 连接池状态:', {
          总连接数: stats.totalConnectionCount,
          可用连接数: stats.availableConnectionCount,
          使用中连接数: stats.checkedOutConnectionCount
        });
      }
    }, 60000); // 每分钟检查一次
  }
}

// 导出单例
module.exports = new DatabaseOptimizer();
```

**2. 缓存策略优化：**
```javascript
// utils/cacheManager.js - 缓存管理器
const Redis = require('redis');
const LRU = require('lru-cache');

class CacheManager {
  constructor() {
    // Redis缓存（分布式）
    this.redis = Redis.createClient({
      host: process.env.REDIS_HOST || 'localhost',
      port: process.env.REDIS_PORT || 6379,
      password: process.env.REDIS_PASSWORD,
      db: 0,
      
      // 连接池配置
      lazyConnect: true,
      maxRetriesPerRequest: 3,
      retryDelayOnFailover: 100,
      enableReadyCheck: false,
      maxRetriesPerRequest: null,
      
      // 性能优化
      compression: 'gzip',
      
      // 连接超时
      connectTimeout: 10000,
      commandTimeout: 5000
    });
    
    // 内存缓存（本地）
    this.memoryCache = new LRU({
      max: 1000, // 最大缓存项数
      ttl: 1000 * 60 * 10, // 10分钟TTL
      updateAgeOnGet: true, // 访问时更新年龄
      allowStale: false
    });
    
    this.setupRedisEvents();
  }
  
  // 设置Redis事件监听
  setupRedisEvents() {
    this.redis.on('connect', () => {
      console.log('✅ Redis连接成功');
    });
    
    this.redis.on('error', (err) => {
      console.error('❌ Redis连接错误:', err);
    });
    
    this.redis.on('ready', () => {
      console.log('🚀 Redis准备就绪');
    });
  }
  
  // 多级缓存获取
  async get(key) {
    try {
      // 1. 先检查内存缓存
      const memoryResult = this.memoryCache.get(key);
      if (memoryResult !== undefined) {
        return memoryResult;
      }
      
      // 2. 检查Redis缓存
      const redisResult = await this.redis.get(key);
      if (redisResult !== null) {
        const parsed = JSON.parse(redisResult);
        
        // 回写到内存缓存
        this.memoryCache.set(key, parsed);
        
        return parsed;
      }
      
      return null;
      
    } catch (error) {
      console.error('缓存获取失败:', error);
      return null;
    }
  }
  
  // 多级缓存设置
  async set(key, value, ttl = 3600) {
    try {
      const serialized = JSON.stringify(value);
      
      // 1. 设置Redis缓存
      await this.redis.setex(key, ttl, serialized);
      
      // 2. 设置内存缓存（较短的TTL）
      this.memoryCache.set(key, value, {
        ttl: Math.min(ttl * 1000, 600000) // 最多10分钟
      });
      
      return true;
      
    } catch (error) {
      console.error('缓存设置失败:', error);
      return false;
    }
  }
  
  // 删除缓存
  async del(key) {
    try {
      // 删除内存缓存
      this.memoryCache.delete(key);
      
      // 删除Redis缓存
      await this.redis.del(key);
      
      return true;
      
    } catch (error) {
      console.error('缓存删除失败:', error);
      return false;
    }
  }
  
  // 批量删除（支持模式匹配）
  async delPattern(pattern) {
    try {
      const keys = await this.redis.keys(pattern);
      
      if (keys.length > 0) {
        // 删除Redis中的键
        await this.redis.del(...keys);
        
        // 删除内存缓存中匹配的键
        for (const key of this.memoryCache.keys()) {
          if (this.matchPattern(key, pattern)) {
            this.memoryCache.delete(key);
          }
        }
      }
      
      return keys.length;
      
    } catch (error) {
      console.error('批量删除缓存失败:', error);
      return 0;
    }
  }
  
  // 模式匹配辅助函数
  matchPattern(str, pattern) {
    const regex = new RegExp(pattern.replace(/\*/g, '.*'));
    return regex.test(str);
  }
  
  // 缓存预热
  async warmup(data) {
    try {
      const promises = Object.entries(data).map(([key, value]) => {
        return this.set(key, value, 7200); // 2小时TTL
      });
      
      await Promise.all(promises);
      console.log(`✅ 缓存预热完成，共${promises.length}个键`);
      
    } catch (error) {
      console.error('缓存预热失败:', error);
    }
  }
  
  // 获取缓存统计
  getStats() {
    return {
      memory: {
        size: this.memoryCache.size,
        max: this.memoryCache.max,
        calculatedSize: this.memoryCache.calculatedSize
      },
      redis: {
        connected: this.redis.status === 'ready'
      }
    };
  }
  
  // 清理所有缓存
  async clear() {
    try {
      this.memoryCache.clear();
      await this.redis.flushdb();
      console.log('✅ 所有缓存已清理');
    } catch (error) {
      console.error('清理缓存失败:', error);
    }
  }
  
  // 关闭连接
  async close() {
    try {
      this.memoryCache.clear();
      await this.redis.quit();
      console.log('📴 缓存管理器已关闭');
    } catch (error) {
      console.error('关闭缓存管理器失败:', error);
    }
  }
}

// 导出单例
module.exports = new CacheManager();
```

### Q31: Socket.IO性能如何优化？
**A:** 实现高性能的Socket.IO优化策略：

```javascript
// sockets/optimizedSocketManager.js - 优化的Socket管理器
const socketIo = require('socket.io');
const Redis = require('redis');
const { createAdapter } = require('@socket.io/redis-adapter');
const rateLimit = require('express-rate-limit');

class OptimizedSocketManager {
  constructor(server) {
    this.server = server;
    this.io = null;
    this.redisClient = null;
    this.redisSubClient = null;
    
    // 连接管理
    this.userConnections = new Map(); // userId -> Set of socket.id
    this.socketUsers = new Map(); // socket.id -> userId
    
    // 性能监控
    this.metrics = {
      totalConnections: 0,
      messagesPerSecond: 0,
      lastMessageCount: 0,
      peakConnections: 0
    };
    
    this.setupSocketIO();
    this.setupRedisAdapter();
    this.setupPerformanceMonitoring();
  }
  
  // 设置Socket.IO服务器
  setupSocketIO() {
    this.io = socketIo(this.server, {
      // 传输优化
      transports: ['websocket', 'polling'],
      
      // 升级超时
      upgradeTimeout: 30000,
      
      // Ping配置
      pingTimeout: 60000,
      pingInterval: 25000,
      
      // 压缩配置
      compression: true,
      
      // 最大HTTP缓冲区大小
      maxHttpBufferSize: 1e6, // 1MB
      
      // 允许的请求数
      allowRequest: this.rateLimitCheck.bind(this),
      
      // CORS配置
      cors: {
        origin: process.env.ALLOWED_ORIGINS?.split(',') || ['http://localhost:5173'],
        methods: ['GET', 'POST'],
        credentials: true
      },
      
      // 连接状态恢复
      connectionStateRecovery: {
        maxDisconnectionDuration: 2 * 60 * 1000, // 2分钟
        skipMiddlewares: true
      }
    });
  }
  
  // 设置Redis适配器（集群支持）
  async setupRedisAdapter() {
    try {
      if (process.env.REDIS_HOST) {
        this.redisClient = Redis.createClient({
          host: process.env.REDIS_HOST,
          port: process.env.REDIS_PORT || 6379,
          password: process.env.REDIS_PASSWORD
        });
        
        this.redisSubClient = this.redisClient.duplicate();
        
        await Promise.all([
          this.redisClient.connect(),
          this.redisSubClient.connect()
        ]);
        
        // 使用Redis适配器
        this.io.adapter(createAdapter(this.redisClient, this.redisSubClient));
        
        console.log('✅ Socket.IO Redis适配器已启用');
      }
    } catch (error) {
      console.error('Redis适配器设置失败:', error);
    }
  }
  
  // 连接限流检查
  rateLimitCheck(req, callback) {
    const ip = req.socket.remoteAddress;
    
    // 检查IP连接数限制
    const ipConnections = Array.from(this.socketUsers.values())
      .filter(userId => {
        // 这里可以根据IP进行更复杂的检查
        return true;
      }).length;
    
    if (ipConnections > 10) { // 每个IP最多10个连接
      callback('Too many connections from this IP', false);
      return;
    }
    
    callback(null, true);
  }
  
  // 设置性能监控
  setupPerformanceMonitoring() {
    // 每秒统计消息数
    setInterval(() => {
      this.metrics.messagesPerSecond = this.metrics.lastMessageCount;
      this.metrics.lastMessageCount = 0;
    }, 1000);
    
    // 每分钟输出性能报告
    setInterval(() => {
      this.logPerformanceMetrics();
    }, 60000);
  }
  
  // 输出性能指标
  logPerformanceMetrics() {
    const memUsage = process.memoryUsage();
    
    console.log('📊 Socket.IO性能指标:', {
      总连接数: this.metrics.totalConnections,
      峰值连接数: this.metrics.peakConnections,
      消息每秒: this.metrics.messagesPerSecond,
      内存使用: {
        RSS: `${Math.round(memUsage.rss / 1024 / 1024)}MB`,
        堆使用: `${Math.round(memUsage.heapUsed / 1024 / 1024)}MB`,
        堆总计: `${Math.round(memUsage.heapTotal / 1024 / 1024)}MB`
      },
      用户连接映射大小: this.userConnections.size,
      Socket映射大小: this.socketUsers.size
    });
  }
  
  // 初始化Socket事件处理
  initializeSocketHandlers() {
    this.io.on('connection', (socket) => {
      this.handleConnection(socket);
    });
  }
  
  // 处理新连接
  handleConnection(socket) {
    // 更新连接统计
    this.metrics.totalConnections++;
    this.metrics.peakConnections = Math.max(
      this.metrics.peakConnections,
      this.metrics.totalConnections
    );
    
    console.log(`🔗 新连接: ${socket.id}`);
    
    // 设置Socket事件处理器
    this.setupSocketEventHandlers(socket);
    
    // 连接断开处理
    socket.on('disconnect', (reason) => {
      this.handleDisconnection(socket, reason);
    });
  }
  
  // 设置Socket事件处理器
  setupSocketEventHandlers(socket) {
    // 用户认证
    socket.on('authenticate', async (data) => {
      await this.handleAuthentication(socket, data);
    });
    
    // 私聊消息（优化版）
    socket.on('private_message', async (data) => {
      await this.handlePrivateMessage(socket, data);
    });
    
    // 用户状态更新
    socket.on('status_update', async (data) => {
      await this.handleStatusUpdate(socket, data);
    });
    
    // 输入状态
    socket.on('typing', (data) => {
      this.handleTyping(socket, data);
    });
    
    // 心跳检测
    socket.on('ping', () => {
      socket.emit('pong');
    });
  }
  
  // 处理用户认证
  async handleAuthentication(socket, data) {
    try {
      const { token } = data;
      
      // 验证JWT token
      const jwtUtils = require('../utils/jwtUtils');
      const verification = jwtUtils.verifyAccessToken(token);
      
      if (!verification.valid) {
        socket.emit('auth_error', { message: 'Invalid token' });
        socket.disconnect();
        return;
      }
      
      const userId = verification.decoded.userId;
      
      // 检查用户连接数限制
      const userSockets = this.userConnections.get(userId) || new Set();
      if (userSockets.size >= 5) { // 每个用户最多5个连接
        socket.emit('auth_error', { message: 'Too many connections' });
        socket.disconnect();
        return;
      }
      
      // 建立用户-Socket映射
      userSockets.add(socket.id);
      this.userConnections.set(userId, userSockets);
      this.socketUsers.set(socket.id, userId);
      
      // 加入用户房间
      socket.join(`user_${userId}`);
      
      // 通知认证成功
      socket.emit('authenticated', {
        userId,
        socketId: socket.id
      });
      
      // 通知好友用户上线
      await this.notifyFriendsOnline(userId);
      
      console.log(`✅ 用户认证成功: ${userId} (${socket.id})`);
      
    } catch (error) {
      console.error('用户认证失败:', error);
      socket.emit('auth_error', { message: 'Authentication failed' });
      socket.disconnect();
    }
  }
  
  // 处理私聊消息（优化版）
  async handlePrivateMessage(socket, data) {
    try {
      // 消息计数
      this.metrics.lastMessageCount++;
      
      const senderId = this.socketUsers.get(socket.id);
      if (!senderId) {
        socket.emit('error', { message: 'Not authenticated' });
        return;
      }
      
      const { receiverId, content, type = 'text' } = data;
      
      // 验证消息内容
      if (!content || content.length > 5000) {
        socket.emit('error', { message: 'Invalid message content' });
        return;
      }
      
      // 检查好友关系（缓存优化）
      const cacheManager = require('../utils/cacheManager');
      const friendshipKey = `friendship:${senderId}:${receiverId}`;
      
      let areFriends = await cacheManager.get(friendshipKey);
      if (areFriends === null) {
        const User = require('../models/User');
        const sender = await User.findById(senderId).select('friends');
        areFriends = sender?.friends?.includes(receiverId) || false;
        
        // 缓存好友关系（5分钟）
        await cacheManager.set(friendshipKey, areFriends, 300);
      }
      
      if (!areFriends) {
        socket.emit('error', { message: 'Not friends with recipient' });
        return;
      }
      
      // 创建消息对象
      const messageData = {
        id: require('crypto').randomUUID(),
        senderId,
        receiverId,
        content,
        type,
        timestamp: new Date(),
        status: 'sent'
      };
      
      // 异步保存到数据库
      this.saveMessageAsync(messageData);
      
      // 立即发送给接收者
      const receiverSockets = this.userConnections.get(receiverId);
      if (receiverSockets && receiverSockets.size > 0) {
        // 发送给接收者的所有连接
        receiverSockets.forEach(socketId => {
          this.io.to(socketId).emit('private_message', {
            ...messageData,
            status: 'delivered'
          });
        });
      } else {
        // 接收者离线，标记为待发送
        messageData.status = 'pending';
      }
      
      // 确认发送给发送者
      socket.emit('message_sent', {
        tempId: data.tempId,
        messageId: messageData.id,
        timestamp: messageData.timestamp,
        status: messageData.status
      });
      
    } catch (error) {
      console.error('处理私聊消息失败:', error);
      socket.emit('error', { message: 'Failed to send message' });
    }
  }
  
  // 异步保存消息
  async saveMessageAsync(messageData) {
    try {
      const Message = require('../models/Message');
      await Message.create(messageData);
    } catch (error) {
      console.error('保存消息失败:', error);
      // 可以考虑将失败的消息放入队列重试
    }
  }
  
  // 处理断开连接
  handleDisconnection(socket, reason) {
    const userId = this.socketUsers.get(socket.id);
    
    if (userId) {
      // 清理连接映射
      const userSockets = this.userConnections.get(userId);
      if (userSockets) {
        userSockets.delete(socket.id);
        
        if (userSockets.size === 0) {
          // 用户完全离线
          this.userConnections.delete(userId);
          this.notifyFriendsOffline(userId);
        }
      }
      
      this.socketUsers.delete(socket.id);
    }
    
    // 更新连接统计
    this.metrics.totalConnections--;
    
    console.log(`🔌 连接断开: ${socket.id} (${reason})`);
  }
  
  // 通知好友用户上线
  async notifyFriendsOnline(userId) {
    try {
      const User = require('../models/User');
      const user = await User.findById(userId).select('friends username avatar');
      
      if (user && user.friends) {
        user.friends.forEach(friendId => {
          const friendSockets = this.userConnections.get(friendId.toString());
          if (friendSockets) {
            friendSockets.forEach(socketId => {
              this.io.to(socketId).emit('friend_online', {
                userId,
                username: user.username,
                avatar: user.avatar
              });
            });
          }
        });
      }
    } catch (error) {
      console.error('通知好友上线失败:', error);
    }
  }
  
  // 通知好友用户离线
  async notifyFriendsOffline(userId) {
    try {
      const User = require('../models/User');
      const user = await User.findById(userId).select('friends');
      
      if (user && user.friends) {
        user.friends.forEach(friendId => {
          const friendSockets = this.userConnections.get(friendId.toString());
          if (friendSockets) {
            friendSockets.forEach(socketId => {
              this.io.to(socketId).emit('friend_offline', { userId });
            });
          }
        });
      }
    } catch (error) {
      console.error('通知好友离线失败:', error);
    }
  }
  
  // 获取在线用户数
  getOnlineUserCount() {
    return this.userConnections.size;
  }
  
  // 获取总连接数
  getTotalConnectionCount() {
    return this.metrics.totalConnections;
  }
  
  // 广播系统消息
  broadcastSystemMessage(message) {
    this.io.emit('system_message', {
      content: message,
      timestamp: new Date(),
      type: 'system'
    });
  }
  
  // 关闭Socket.IO服务器
  async close() {
    try {
      if (this.redisClient) {
        await this.redisClient.quit();
      }
      if (this.redisSubClient) {
        await this.redisSubClient.quit();
      }
      
      this.io.close();
      console.log('📴 Socket.IO服务器已关闭');
    } catch (error) {
      console.error('关闭Socket.IO服务器失败:', error);
    }
  }
}

module.exports = OptimizedSocketManager;
```

---

## 项目架构问答

### Q32: 项目的目录结构是如何组织的？
**A:** 
```
Coffee-Chat-Bar/
├── ccb/                    # 前端项目
│   ├── src/
│   │   ├── components/     # Vue组件
│   │   ├── views/         # 页面组件
│   │   ├── router/        # 路由配置
│   │   ├── stores/        # Pinia状态管理
│   │   └── utils/         # 工具函数
│   ├── main.js           # Electron主进程
│   └── vite.config.js    # Vite配置
└── server/               # 后端项目
    ├── models/           # 数据模型
    ├── routes/           # 路由处理
    ├── sockets/          # Socket.IO事件
    ├── middlewares/      # 中间件
    ├── config/           # 配置文件
    └── server.js         # 服务器入口
```

### Q33: 如何实现前后端分离部署？
**A:** 
1. **开发环境**: 前端Vite dev server + 后端Node.js server
2. **生产环境**: 前端构建静态文件，后端提供API服务
3. **代理配置**: Vite代理解决开发环境跨域
4. **环境变量**: 不同环境使用不同的API地址

### Q34: 项目的扩展性如何？
**A:** 
1. **模块化设计**: 组件、路由、状态管理分离
2. **插件系统**: Vite插件，Express中间件
3. **数据库设计**: MongoDB灵活的Schema
4. **微服务准备**: 路由模块化，便于拆分服务

---

## Electron桌面端问答

### Q35: 为什么要开发桌面端？
**A:** 
1. **用户体验**: 原生应用体验，无需浏览器
2. **系统集成**: 可以集成系统通知、托盘等
3. **离线能力**: 部分功能可以离线使用
4. **跨平台**: 一套代码支持Windows、macOS、Linux

### Q36: Electron是如何配置的？
**A:** 在`main.js`中配置：
```javascript
import { app, BrowserWindow } from 'electron'

let mainWindow;

function createWindow() {
  mainWindow = new BrowserWindow({
    width: 1200,
    height: 800,
    webPreferences: {
      nodeIntegration: false,
      contextIsolation: true
    }
  })
  
  // 开发环境加载dev server，生产环境加载构建文件
  const isDev = process.env.NODE_ENV === 'development'
  if (isDev) {
    mainWindow.loadURL('http://localhost:5173')
  } else {
    mainWindow.loadFile('dist-new/index.html')
  }
}
```

### Q37: 如何处理Electron的安全性？
**A:** 
1. **禁用Node集成**: `nodeIntegration: false`
2. **启用上下文隔离**: `contextIsolation: true`
3. **URL验证**: 限制导航到可信域名
4. **CSP策略**: 内容安全策略

### Q38: Electron应用如何打包发布？
**A:** 使用electron-builder：
```json
"scripts": {
  "dist": "npm run build && electron-builder --publish=never",
  "dist-win": "npm run build && electron-builder --win"
},
"build": {
  "appId": "com.example.ccb",
  "productName": "Mini Chat Bar",
  "files": ["dist-new/**/*", "main.js", "package.json"]
}
```

---

## 总结

### Q39: 这个项目最大的技术挑战是什么？
**A:** 
1. **实时通信**: Socket.IO的连接管理和消息同步
2. **状态管理**: 复杂的聊天状态和用户状态管理
3. **跨平台兼容**: Web端和桌面端的兼容性
4. **文件传输**: 大文件上传和实时传输

### Q40: 如果重新设计这个项目，你会做哪些改进？
**A:** 
1. **TypeScript**: 增加类型安全
2. **微服务架构**: 拆分用户服务、消息服务、文件服务
3. **Redis缓存**: 缓存用户状态和热点数据
4. **消息队列**: 使用RabbitMQ处理高并发消息
5. **CDN**: 文件存储使用云存储服务
6. **单元测试**: 增加完整的测试覆盖

### Q41: 项目中学到的最重要的技术点是什么？
**A:** 
1. **全栈开发思维**: 前后端协调设计
2. **实时通信**: WebSocket的实际应用
3. **状态管理**: 复杂应用的状态设计
4. **安全意识**: 认证、授权、数据安全
5. **性能优化**: 从前端到后端的全链路优化

---

## 面试建议

1. **准备Demo**: 能够现场演示项目功能
2. **代码熟悉**: 对每个文件的作用都要清楚
3. **技术深度**: 不仅知道怎么用，还要知道为什么这样设计
4. **问题解决**: 准备讲述开发过程中遇到的问题和解决方案
5. **扩展思考**: 思考项目的改进方向和技术演进

**记住**: 面试官更关心你的思考过程和解决问题的能力，而不仅仅是技术的使用。结合具体代码讲解，展示你对技术的深入理解！